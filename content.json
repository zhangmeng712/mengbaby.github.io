{"meta":{"title":"萌小主前端部落","subtitle":"the more you know the more you know you don't know","description":"the more you know the more you know you don't know","author":"Dr Meng","url":"https://mengbaby.github.io"},"pages":[{"title":"分类","date":"2017-04-16T17:34:01.000Z","updated":"2017-04-17T05:27:30.000Z","comments":true,"path":"categories/index.html","permalink":"https://mengbaby.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签云","date":"2017-04-16T17:33:49.000Z","updated":"2017-04-17T05:26:29.000Z","comments":false,"path":"tags/index.html","permalink":"https://mengbaby.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"前端自动化测试（三）- angular和protracor","slug":"f2e-testing-angular","date":"2016-03-09T20:53:58.000Z","updated":"2017-04-17T07:02:37.000Z","comments":true,"path":"2016/03/10/f2e-testing-angular/","link":"","permalink":"https://mengbaby.github.io/2016/03/10/f2e-testing-angular/","excerpt":"","text":"protractor用于前端UI自动化测试,特别为angular程序定制 特点 端对端(e2e)测试 采用jasmine作为测试框架 基于WebDriverJS,(selenium-webdriver) 针对angular应用增加定位器,更加方便实用 实现自动等待,告别sleep wait,变异步为同步 支持测试代码的调试 支持多浏览器的并行UI测试 使用方法准备工作 1 安装protractor: npm install -g protractor 2 安装selenium-standlone: webdriver-manager update 3 启动selenium服务器: webdriver-manager start spec书写spec.js是用于书写测试用例的文件, protractor默认使用jasmine作为测试框架,举最简单的例子来说,一个spec文件可以这样写,使用describe作为测试程序”块”, it定义一个用例,expect作为断言,其中browser这个全局的变量,用于操作浏览器.123456describe('Protractor Demo App', function() &#123; it('should have a title', function() &#123; browser.get('http://juliemr.github.io/protractor-demo/'); expect(browser.getTitle()).toEqual('Super Calculator'); &#125;);&#125;); 运行 配置conf.json在测试之前,我们需要建立一个conf.json的文件,在这个文件中,可以配置测试的相关内容,例如: multiCapabilities:使用哪些浏览器测试 chromeOptions:chrome浏览器的运行参数(使用哪些插件等) framework:使用哪种测试框架: cucumber macha 还是jasmine specs:测试哪些文件详细的配置信息请参考 12345678910111213141516171819202122232425exports.config = &#123; // directConnect: true, // Capabilities to be passed to the webdriver instance. //capabilities: &#123; // 'browserName': 'chrome' //&#125;, multiCapabilities: [ &#123; 'browserName': 'chrome', //'chromeOptions': &#123; // 'args': ['--load-extension=/opt/local/share/nginx/html/radar/tanxtag'], //&#125; &#125;], // Framework to use. Jasmine is recommended. framework: 'jasmine', // Spec patterns are relative to the current working directly when // protractor is called. specs: ['basic/demo_spec.js','basic/angular_spec.js'], // Options to be passed to Jasmine. jasmineNodeOpts: &#123; defaultTimeoutInterval: 30000 &#125;&#125;; 运行测试程序 1protractor conf.json grunt运行测试有时我们需要使用grunt来配置测试任务,下面就是使用grunt-concurrent 模块实现并行运行多浏览器(也可通过conf.json中配置multiCapabilities解决)测试程序的代码:12345678910111213141516171819202122232425262728293031323334353637383940414243module.exports = grunt =&gt; &#123; //This module will read the dependencies/devDependencies/peerDependencies/optionalDependencies in your package.json // and load grunt tasks that match the provided patterns. require('load-grunt-tasks')(grunt); grunt.initConfig(&#123; concurrent: &#123; protractor_test: ['protractor-chrome', 'protractor-firefox', 'protractor-safari'] &#125;, protractor: &#123; options: &#123; keepAlive: true, singleRun: false, configFile: \"conf.js\" &#125;, run_chrome: &#123; options: &#123; args: &#123; browser: \"chrome\" &#125; &#125; &#125;, run_firefox: &#123; options: &#123; args: &#123; browser: \"firefox\" &#125; &#125; &#125;, run_safari: &#123; options: &#123; args: &#123; browser: \"safari\" &#125; &#125; &#125; &#125; &#125;); grunt.registerTask('protractor-chrome', ['protractor:run_chrome']); grunt.registerTask('protractor-firefox', ['protractor:run_firefox']); grunt.registerTask('protractor-safari', ['protractor:run_safari']); grunt.registerTask('protractor-e2e', ['concurrent:protractor_test']);&#125;; 调试测试程序除了非常方便的运行机制,protractor还提供便捷的调试方式, 使用selenium-webdriver操纵浏览器的时候,调试是非常困难的,在这里protractor就提供调试方式在代码中加入 browser.pause(); 并且在终端输入 “repl” 就可以使用WebDriver commands来调试程序了: 123456wd-debug&gt; repl&gt; elementfunction (locator) &#123; return new ElementArrayFinder(ptor).all(locator).toElementFinder_(); &#125;&gt; 测试非angular的应用protractor内置方法测试angular的程序,例如它会自动检测angular页面加载完毕才会执行测试程序,当测试非angular程序的时候需要: - 1 使用 browser.driver 代替 driver - 2 添加 browser.driver.ignoreSynchronization = true 参考 protractor的详细使用在protractor中,有几大类用于测试代码,详情请见protractorAPI browser: 浏览器的操作 element &amp; by: 定位获取页面元素 ExpectedConditions:用于页面操作的逻辑函数,一般同wait连用 webdriver: selenium 原生的语法函数 promise:selenium内置的promise方法 浏览器的操作-browser常用操作代码如下: browser.get: browser.findElement browser.switchTo().frame() browser.executeScript: browser.executeAsyncScript browser.wait: browser.sleep: 选择器- by &amp; element支持多源选择器 by.css() by.id() by.xpath() by.name() by.tagName() by.model():angular专用 by.binding():angular专用 by.repeater():angular专用 通过element获取:element(by.id(‘frameId’))或者element.all(by.css(‘some-css’));在非angular应用中使用browser.driver.findElement(by.id(‘frameId’)) ExpectedConditions预定义了wait的条件,常用的有 elementToBeClickable: 按钮可以点击 presenceOf: 元素出现在dom中 titleContains: title含有某个字符串 visibilityOf: 某个元素显示 1234567var EC = protractor.ExpectedConditions;var button = $('#xyz');var isClickable = EC.elementToBeClickable(button);browser.get(URL);browser.wait(isClickable, 5000); //wait for an element to become clickablebutton.click(); 综合实例12345678910111213141516it ('test login error', function () &#123; _driver.get('http://subway.simba.taobao.com/#!/login'); _driver.wait(protractor.until.elementLocated(by.css('.login-ifr')),1000).then(function (elem) &#123; _driver.switchTo().frame(elem); _driver.findElement(by.name('TPL_username')).sendKeys('zhangmeng1986712'); _driver.findElement(by.name('TPL_password')).sendKeys('xxxxx'); _driver.findElement(by.id('J_SubmitStatic')).click(); _driver.sleep(1000); browser.driver.findElement(by.css('.error')).then(function (elem) &#123; return elem.getInnerHtml().then(function(text) &#123; expect(text).toMatch('密码和账户名不匹配'); &#125;); &#125;); &#125;); &#125;); page object patternpage object的模式大家一定不陌生,通过合理的配置可以使测试代码更容易维护,举例来说可以这样: 1234567891011121314151617181920212223242526//书写一个input操作类var AngularHomepage = function() &#123; var nameInput = element(by.model(&apos;yourName&apos;)); var greeting = element(by.binding(&apos;yourName&apos;)); this.get = function() &#123; browser.get(&apos;http://www.angularjs.org&apos;); &#125;; this.setName = function(name) &#123; nameInput.sendKeys(name); &#125;; this.getGreeting = function() &#123; return greeting.getText(); &#125;;&#125;;//测试代码describe(&apos;angularjs homepage&apos;, function() &#123; it(&apos;should greet the named user&apos;, function() &#123; var angularHomepage = new AngularHomepage(); angularHomepage.get(); angularHomepage.setName(&apos;Julie&apos;); expect(angularHomepage.getGreeting()).toEqual(&apos;Hello Julie!&apos;); &#125;);&#125;); mobile端的测试详情参考这个例子是使用Appium作为server端进行测试的,由于selenium-webdriver不能直接联Appium, 所以需要使用wd-bridge进行折衷. e2e测试程序设计准则参考 参考代码本文的参考代码见 Github","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://mengbaby.github.io/categories/nodejs/"},{"name":"testing","slug":"nodejs/testing","permalink":"https://mengbaby.github.io/categories/nodejs/testing/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://mengbaby.github.io/Mtags/nodejs/"},{"name":"angular","slug":"angular","permalink":"https://mengbaby.github.io/Mtags/angular/"},{"name":"e2e","slug":"e2e","permalink":"https://mengbaby.github.io/Mtags/e2e/"},{"name":"protractor","slug":"protractor","permalink":"https://mengbaby.github.io/Mtags/protractor/"}]},{"title":"前端自动化测试之单元测试（二）—— react组件的测试工具jest","slug":"f2e-testing-jest","date":"2016-02-09T22:47:02.000Z","updated":"2017-04-17T07:15:39.000Z","comments":true,"path":"2016/02/10/f2e-testing-jest/","link":"","permalink":"https://mengbaby.github.io/2016/02/10/f2e-testing-jest/","excerpt":"","text":"前面介绍了Polymer的测试框架web-components-tester, 今天来看看React团队出品的Jest.在此,特别感谢婆婆帮忙带宝宝才让我有时间继续书写文章. 前面介绍了Polymer的测试框架web-components-tester, 今天来看看React团队出品的Jest.在此,特别感谢婆婆帮忙带宝宝才让我有时间继续书写文章. Jest的功能 内置jasmine 内置mock函数 可以mock模块 基于jsdom 同步化书写异步代码 真心赞一下简洁明了的API定义和用法 以及清晰的文档,确实让书写单元测试不再痛苦 适用于commonJS模块的单元测试 运行速度较慢 Jest用法 安装: npm install jest-cli(需要node版本大于4) 配置 package.json 如下 运行: npm test 调试(使用node-debug再浏览器中调试)：node-debug –nodejs –harmony ./node_modules/jest-cli/bin/jest.js –runInBand tests/getUser-test.js 运行单个文件 ./node_modules/jest-cli/bin/jest.js tests/getUser-test.js 12345678&#123; \"name\": \"jest-test-examples\", \"version\": \"0.0.1\", \"dependencies\": &#123;&#125;, \"scripts\": &#123; \"test\": \"jest\" &#125;&#125; 下面就具体介绍一下使用jest进行测试的方法,采用的例子为jest的官方实例 一个简单的测试1234567jest.dontMock('../src/sum');describe('sum', function() &#123; it('adds 1 + 2 to equal 3', function() &#123; var sum = require('../src/sum'); expect(sum(1, 2)).toBe(3); &#125;);&#125;); describe和it还有expect都使用了jasmine的语法, jest会自动mock所有的依赖模块,对模块中所有的输出方法予以遍历并进行mock,对于要测试的模块使用jest.dontMock标识,jest就不会去mock. 异步的单元测试实例异步是javascript的灵魂, 所以异步的测试也是极其重要的,下面看看jest关于异步程序的测试,假如有这样个ajax程序,获取数据并进行解析,对其进行测试 1 ajax的数据获取是否正确 2 parseUserJson是否正确在第二个测试用例中使用了genMockFunction,用来对回调函数进行mock,在jest中有两种方式进行函数的mock 1 使用xFunc = require(‘xx’); 2 使用xFunc = jest.genMockFunction();使用后,会在xFunc.calls中存储有关函数的调用信息,例如 //mock.calls.length 记录了函数被调用了几次 //mock.calls[0][0] 被调用函数的第一个参数 //mock.calls[0][1] 第二个参数代码如下: $.ajax是一个被mock的函数,callback也被mock,getUser(callback)调用后,可以通过检测传递的参数判断是否正确. 1234567891011121314151617var $ = require('jquery');function parseUserJson(userJson) &#123; return &#123; loggedIn: true, fullName: userJson.firstName + ' ' + userJson.lastName &#125;;&#125;function fetchCurrentUser(callback) &#123; return $.ajax(&#123; type: 'GET', url: 'http://example.com/currentUser', success: function(userJson) &#123; callback(parseUserJson(userJson)); &#125; &#125;);&#125;module.exports = fetchCurrentUser; 123456789101112131415161718192021222324252627282930313233343536373839404142434445jest.dontMock('../src/getUser');describe('getUser', function() &#123; //test right params it('calls into $.ajax with the correct params', function() &#123; var $ = require('jquery'); var getUser = require('../src/getUser'); function dummyCallback() &#123;&#125; getUser(dummyCallback); // Now make sure that $.ajax was properly called during the previous // 2 lines expect($.ajax).toBeCalledWith(&#123; type: 'GET', url: 'http://example.com/currentUser', success: jasmine.any(Function) &#125;); &#125;); //test callback function it('calls the callback when $.ajax requests are finished', function() &#123; var $ = require('jquery'); var getUser = require('../src/getUser'); //create mock function var callback = jest.genMockFunction(); getUser(callback); //xfunc.mock have interactions information //mock.calls.length call times //mock.calls[0][0] first param //mock.calls[0][1] second param //https://facebook.github.io/jest/docs/mock-functions.html //emulate the params pass to success $.ajax.mock.calls[0][0].success(&#123; firstName: 'Bobby', lastName: '\");DROP TABLE Users;--' &#125;); expect(callback.mock.calls[0][0]).toEqual(&#123; loggedIn: true, fullName: 'Bobby \");DROP TABLE Users;--' &#125;); &#125;);&#125;); React组件的单元测试实例假如我们有这样一个checkbox react组件, 如下, react的es6写法请参考我的blog-ES6的核心语法与应用原理非常简单,点击checkbox切换label的状态.我们的测试代码如下, 使用了react-addons-test-utils这个模块, 模块的renderIntoDocument用于将react组件渲染到document中,并且支持产生模拟事件:TestUtils.Simulate.change.12345678910111213141516171819import React from 'react';class Checkbox extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;isChecked: false&#125;; this.changeState = this.changeState.bind(this); &#125; changeState () &#123; this.setState(&#123;isChecked: !this.state.isChecked&#125;) &#125; render() &#123; return (&lt;label&gt; &lt;input type=\"checkbox\" checked=&#123;this.state.isChecked&#125; onChange=&#123;this.changeState&#125; /&gt; &#123;this.state.isChecked ? this.props.labelOn : this.props.labelOff&#125; &lt;/label&gt;) &#125;&#125;export default Checkbox; 12345678910111213141516171819202122232425import React from 'react';import TestUtils from 'react-addons-test-utils';import ReactDom from 'react-dom';jest.dontMock('../src/checkbox');const Checkbox = require('../src/checkbox');describe('test react checkbox component', () =&gt; &#123; it('change the label after click', () =&gt; &#123; //1 render component //2 get node label get default value off //3 simulate click //4 expect value equal on //TestUtils.renderIntoDocument method refers to https://facebook.github.io/react/docs/test-utils.html#renderintodocument //TestUtils.findRenderedDOMComponentWithTag https://facebook.github.io/react/docs/test-utils.html#findrendereddomcomponentwithtag //ReactDom API:findDOMNode render unmountComponentAtNode server-side:renderToString renderToStaticMarkup var checkbox = TestUtils.renderIntoDocument(&lt;Checkbox labelOn=\"On\" labelOff=\"Off\" /&gt;); var checkboxNode = ReactDom.findDOMNode(checkbox); //https://facebook.github.io/jest/docs/api.html#expect-value expect(checkboxNode.textContent).toEqual('Off'); TestUtils.Simulate.change(TestUtils.findRenderedDOMComponentWithTag(checkbox, 'input')); expect(checkboxNode.textContent).toEqual('On'); &#125;);&#125;); 运行的时候我们需要通过babel预处理一下,通过如下的方式配置package.json即可运行: 1234567891011121314\"scripts\": &#123; \"test\": \"jest\"&#125;,\"jest\": &#123; \"scriptPreprocessor\": \"&lt;rootDir&gt;/node_modules/babel-jest\", \"unmockedModulePathPatterns\": [ \"&lt;rootDir&gt;/node_modules/react\", \"&lt;rootDir&gt;/node_modules/react-dom\", \"&lt;rootDir&gt;/node_modules/react-addons-test-utils\" ], \"modulePathIgnorePatterns\": [ \"&lt;rootDir&gt;/node_modules/\" ]&#125; 手动mock经常我们需要模拟某个模块中的方法(此方法实现非常复杂依赖第三方的模块)用来测试另一个模块的输入输出是否正确,jest就提供非常方便的mock机制,例如,我们在A模块中依赖jquery的fx方法而fx方法又依赖于其他方法, 因为我们只关心fx的输出,所以我们就可以直接用来模拟,方法如下: 建立mocks文件夹 新建jquery模块:jquery.js 使用genMockFromModule和mockImplementation API 如下 123456789// mock the module of real jqueryvar jqueryMocks = jest.genMockFromModule('jquery');var mock_fx = function () &#123; return 'mockValue';&#125;;//using mock_fx to mock the function of real fxjqueryMocks.fx.mockImplementation(mock_fx);module.exports = jqueryMocks; 这样就可以在测试代码中直接引用已经模拟好的fx函数进行测试了,直接对模块的输入控制,减少了依赖,实现测试的”解耦”. 123456describe('jest mocks', function () &#123; it('jquery mock getEnv value', function()&#123; var value = require('jquery').fx(); expect(value).toEqual('mockValue') &#125;);&#125;); 代码参考源码","categories":[{"name":"Uncategorized","slug":"Uncategorized","permalink":"https://mengbaby.github.io/categories/Uncategorized/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mengbaby.github.io/Mtags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://mengbaby.github.io/Mtags/nodejs/"},{"name":"React","slug":"React","permalink":"https://mengbaby.github.io/Mtags/React/"},{"name":"jest","slug":"jest","permalink":"https://mengbaby.github.io/Mtags/jest/"},{"name":"前端单元测试","slug":"前端单元测试","permalink":"https://mengbaby.github.io/Mtags/前端单元测试/"}]},{"title":"ES6的核心语法与应用","slug":"es6-basic","date":"2016-01-24T06:28:03.000Z","updated":"2017-04-17T07:22:29.000Z","comments":true,"path":"2016/01/24/es6-basic/","link":"","permalink":"https://mengbaby.github.io/2016/01/24/es6-basic/","excerpt":"","text":"一直以来都对ES6嗤之以鼻，本来灵活简单的Javascrit，非得为了提升B格，增加学习的成本，搞那么多鸡肋的语法。但是无奈俺们这些“老年jser”都被历史的车轮碾压了，现在如果不掌握ES6，估计很多代码都看不懂了。没有闲暇的午后时间来系统的学习ES6（其实还是有点抵触心理），但是为了跟上“年轻人”的步伐，随着用随着看随着学吧。力求以最简单的语言讲述。 模块定义模块语法为： export function x () {} export class export default {} 12345678910111213141516// kittydar.js - 找到一幅图像中所有猫的位置 export function detectCats(canvas, options) &#123; var kittydar = new Kittydar(options); return kittydar.detectCats(canvas); &#125; export class Kittydar &#123; ... 处理图片的几种方法 ... &#125; // 这个helper函数没有被export。 function resizeCanvas() &#123; ... &#125; //默认的 export default &#123; xx: '111' &#125; 引用模块12345678910111213141516171819202122232425262728293031323334353637383940 import &#123;detectCats&#125; from \"kittydar.js\"; //引入某个方法 import &#123;detectCats, Kittydar&#125; from \"kittydar.js\"; //引入并重命名 import * as module from './module';//引入全部全部 import helloWorld from './hello-world'; //引入默认 function go() &#123; var canvas = document.getElementById(\"catpix\"); var cats = detectCats(canvas); drawRectangles(canvas, cats); &#125;``` ## class用法- 基本语法 class A &#123;&#125;- 构造器 constructor &#123;&#125;- 继承 class A extends AParent &#123;&#125;- super()- 注意：类声明与函数声明不同，它不会被提升,所以先new 后class定义 会抛出异常- 静态变量：static compare(a, b) &#123;&#125;```javascript//ES5//使用Object.defineProperty实现可读属性make yearfunction Vehicle(make, year) &#123; Object.defineProperty(this, 'make', &#123; get: function() &#123; return make; &#125; &#125;); Object.defineProperty(this, 'year', &#123; get: function() &#123; return year; &#125; &#125;);&#125;Vehicle.prototype.toString = function() &#123; return this.make + ' ' + this.year;&#125;var vehicle = new Vehicle('Toyota Corolla', 2009);console.log(vehicle.make); // Toyota Corollavehicle.make = 'Ford Mustang'; //静态属性console.log(vehicle.toString()) // Toyota Corolla 2009 12345678910111213141516171819202122232425//ES6class Vehicle &#123; constructor(make, year) &#123; this._make = make; this._year = year; &#125; get make() &#123; return this._make; &#125; get year() &#123; return this._year; &#125; toString() &#123; return 'xxx'; &#125;&#125;var vehicle = new Vehicle('Toyota Corolla', 2009);console.log(vehicle.make); // Toyota Corollavehicle.make = 'Ford Mustang';console.log(vehicle.toString()) // Toyota Corolla 2009 1234567891011121314151617181920212223//ES5的继承function Motorcycle(make, year) &#123; Vehicle.apply(this, [make, year]);&#125;Motorcycle.prototype = Object.create(Vehicle.prototype, &#123; toString: function() &#123; return 'xxx'; &#125;&#125;);Motorcycle.prototype.constructor = Motorcycle;//ES6class Motorcycle extends Vehicle &#123; constructor(make, year) &#123; super(make, year); &#125; toString() &#123; return 'xxxx'; &#125;&#125; 箭头函数 箭头函数的产生，主要由两个目的：更简洁的语法和与父作用域共享关键字this。 function和{}都消失了，所有的回调函数都只出现在了一行里。 当只有一个参数时，()也消失了（rest参数是一个例外，如(…args) =&gt; …）。 当{}消失后，return关键字也跟着消失了。单行的箭头函数会提供一个隐式的return（这样的函数在其他编程语言中常被成为lamda函数）。 箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。 箭头函数与普通函数还有一个区别就是，它没有自己的arguments变量，但可通过rest参数获得。 123456789101112131415161718function () &#123; return 1; &#125;() =&gt; &#123; return 1; &#125;() =&gt; 1 function (a) &#123; return a * 2; &#125;(a) =&gt; &#123; return a * 2; &#125;(a) =&gt; a * 2a =&gt; a * 2 function (a, b) &#123; return a * b; &#125;(a, b) =&gt; &#123; return a * b; &#125;(a, b) =&gt; a * b function () &#123; return arguments[0]; &#125;(...args) =&gt; args[0] () =&gt; &#123;&#125; // undefined() =&gt; (&#123;&#125;) // &#123;&#125; 12345//在之前的js中setInterval会把this指向window，//使用箭头函数this使用外层的作用域所以不用保存this指针$('.current-time').each(function () &#123; setInterval(() =&gt; $(this).text(Date.now()), 1000);&#125;); 123456//箭头函数的arguments，通过rest函数可以获得function log(msg) &#123; const print = (...args) =&gt; console.log(args[0]); print(`LOG: $&#123;msg&#125;`);&#125; log('hello'); // LOG: hello 作用域javascript本身是没有块级作用域的，ES6新增的let语法替代var实现了块级作用域。 1234567891011121314//beforefunction func(arr) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; // i ... &#125; // 这里也可以访问到i&#125;//ES6function func(arr) &#123; for (let i = 0; i &lt; arr.length; i++) &#123; // i ... &#125; // 这里访问不到i&#125; React on ES6详情参考 这篇文章 定义组件12345678910// The ES5 wayvar Photo = React.createClass(&#123; handleDoubleTap: function(e) &#123; … &#125;, render: function() &#123; … &#125;,&#125;);// The ES6+ wayclass Photo extends React.Component &#123; handleDoubleTap(e) &#123; … &#125; render() &#123; … &#125;&#125; componentWillMount关键字1234567891011// The ES5 wayvar EmbedModal = React.createClass(&#123; componentWillMount: function() &#123; … &#125;,&#125;);// The ES6+ wayclass EmbedModal extends React.Component &#123; constructor(props) &#123; super(props); //实现componentWillMount内容的地方像dom操作 &#125;&#125; state和props初始化123456789101112131415161718192021222324252627282930313233343536373839// The ES5 wayvar Video = React.createClass(&#123; getDefaultProps: function() &#123; return &#123; autoPlay: false, maxLoops: 10, &#125;; &#125;, getInitialState: function() &#123; return &#123; loopsRemaining: this.props.maxLoops, &#125;; &#125;, propTypes: &#123; autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired, posterFrameSrc: React.PropTypes.string.isRequired, videoSrc: React.PropTypes.string.isRequired, &#125;,&#125;);// The ES6+ way// static 实现只读的props// 全局stateclass Video extends React.Component &#123; static defaultProps = &#123; autoPlay: false, maxLoops: 10, &#125; static propTypes = &#123; autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired, posterFrameSrc: React.PropTypes.string.isRequired, videoSrc: React.PropTypes.string.isRequired, &#125; state = &#123; loopsRemaining: this.props.maxLoops, &#125;&#125; react中的事件12345678910111213141516171819class PostInfo extends React.Component &#123; constructor(props) &#123; super(props); // Manually bind this method to the component instance... this.handleOptionsButtonClick = this.handleOptionsButtonClick.bind(this); &#125; handleOptionsButtonClick(e) &#123; // this应指向实例 this.setState(&#123;showOptionsModal: true&#125;); &#125;&#125;//箭头函数this指向外层的组件class PostInfo extends React.Component &#123; handleOptionsButtonClick = (e) =&gt; &#123; this.setState(&#123;showOptionsModal: true&#125;); &#125;&#125; 实例使用ES6改写的React组件程序 12345678910111213141516171819import React from 'react'class Checkbox extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;isChecked: false&#125;; this.changeState = this.changeState.bind(this); &#125; changeState () &#123; this.setState(&#123;isChecked: !this.state.isChecked&#125;) &#125; render() &#123; return (&lt;label&gt; &lt;input type=\"checkbox\" checked=&#123;this.state.isChecked&#125; onChange=&#123;this.changeState&#125; /&gt; &#123;this.state.isChecked ? this.props.labelOn : this.props.labelOff&#125; &lt;/label&gt;) &#125;&#125;export default Checkbox;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://mengbaby.github.io/categories/javascript/"},{"name":"es6","slug":"javascript/es6","permalink":"https://mengbaby.github.io/categories/javascript/es6/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mengbaby.github.io/Mtags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://mengbaby.github.io/Mtags/ES6/"},{"name":"React","slug":"React","permalink":"https://mengbaby.github.io/Mtags/React/"}]},{"title":"前端自动化测试之单元测试（一）—— polymer组件的测试工具","slug":"f2e-testing-polymer","date":"2015-12-30T20:04:54.000Z","updated":"2017-04-17T05:55:31.000Z","comments":true,"path":"2015/12/31/f2e-testing-polymer/","link":"","permalink":"https://mengbaby.github.io/2015/12/31/f2e-testing-polymer/","excerpt":"","text":"单元测试的工具们 单元测试框架 * Qunit - jquery的单测工具 jasmine - 早期的测试框架 mocha - 常用框架 支持BDD和TDD Cucumber - 语义化更好的测试工具 断言 * chai 集成 * Karma jenkins travis-ci mock * sinon supertest 组件测试框架 * polymer的单测工具：web-component-tester react的单测工具：Jest 之前的博客对比较基础的测试工具都有所介绍，参考前端自动化测试基础篇，在这篇blog中，我们首先了解一下polymer组件的单元测试工具。 mocha chai sinon why web-component-testerweb-component-tester是polymer组件用于单元测试的框架,主要是用作对于html文件的测试 它内部集成了mocha、sinon、sinon-chai、chai，方便使用 使用lodash作为工具函数 async用作异步函数的测试 test-fixture作为模板的测试 accessibility-developer-tools将测试结果输出到命令行中。 在server端wct内置selenium-standalone，在客户端使用wd.js操作服务器进行测试 API方法基本API WCT.loadSuites可以将 suite类似describe将测试进行归类 test类似it进行具体的测试 assert用于进行断言，断言同chai的assert的断言规则 suite(‘AwesomeLib’, function() { test(‘is awesome’, function() { assert.isTrue(AwesomeLib.awesome);//TDD模式 });});` 特殊的方法 text-fixture 用来在测试过程中操作template中的dom元素，用法是在外部用包裹起来。然后就可以通过fixture获取元素，按照dom进行操作。 `&lt;test-fixture id=\"simple\"&gt; &lt;template&gt; &lt;div&gt;&lt;/div&gt; &lt;/template&gt; &lt;/test-fixture&gt; &lt;script&gt; suite('classList', function() { var div; setup(function() { div = fixture('simple'); }) test('foo', function() { div.classList.add('foo'); assertSomethingOrOther(div); }); }); &lt;/script&gt; ` 关于template binding异步的测试异步测试在javascript的世界中可谓最常见，对于polymer组件来说，数据驱动模板刷新很重要，模板数据的刷新会调用Polymer.dom.flush, 它是个异步的过程，对此 web-components-tester 专门提供flush函数处理此类异步。 `suite('with two selected items', function() { // Clean up after ourselves. teardown(function(done) { s.clearSelection(); s.multi = false; // Wait for observers to resolve before moving on to more tests. flush(done); }); test('multi selects by index', function(done) { s.multi = true; //数据变化 s.selected = [0, 2]; flush(function() { //模板刷新 assert.equal(s.selectedIndex, [0, 2]); assert(s.children[0].classList.contains('core-selected')); assert(!s.children[1].classList.contains('core-selected')); assert(s.children[2].classList.contains('core-selected')); done(); }); }); }); ` google map component测试实例 代码参考，f2e test 1、安装 web-components-tester： npm install -g web-component-tester 2 建立test文件夹（默认地址） * 2.1 index.html 2.2 google-map-marker.html 2.3 marker.js ` suite('markers default', function () { var map; setup(function () { map = document.querySelector('#map'); }); test('markers are initialized', function () { var markerEl = Polymer.dom(map).querySelector('google-map-marker'); assert.isUndefined(markerEl.marker); assert.isUndefined(markerEl.map); assert.isNull(markerEl.info); assert.equal(markerEl.latitude, 37.779); assert.equal(markerEl.longitude, -122.3892); }); test('markers are added to map', function () { map.addEventListener('google-map-ready', function () { var mapMarkerEl = Polymer.dom(map).querySelector('google-map-marker'); var firstMarker = map.markers[0]; expect(firstMarker).to.deep.equal(mapMarkerEl); assert.equal(map.markers.length, 3); }); }); test('markers position can be updated', function (done) { map.addEventListener('google-map-ready', function (e) { var markerEl = Polymer.dom(map).querySelector('google-map-marker'); markerEl.latitude = 37.79493; markerEl.longitude = -122.41942; markerEl.zIndex = 1; assert.equal(markerEl.map, map.map, \"marker's map is not the google-map's\"); //重新渲染 异步过程 Polymer.dom.flush(); async.nextTick(function () { var marker = markerEl.marker; assert.equal(marker.getPosition().lat(), markerEl.latitude); assert.equal(marker.getPosition().lng(), markerEl.longitude); assert.equal(marker.getZIndex(), markerEl.zIndex); done(); }); }); }); }); ` 3 运行测试脚本 wct 即可。 wct运行机制代码：runner 建立webserver，模板参见index.html 读取wct.conf.json配置 内置selenium server 通过wd.js建立连接打开浏览器进行测试 并将结果通过socketIO返回显示在命令行 测试框架核心：browser.js， 源码内置chai mocha sinon socket等以及polymer测试的辅助函数 辅助工具在测试中少不了点击事件的模拟，wct这个工具不具有这个功能，但是可以使用polymer的工具组件iron-test-helpers它内置了MockInteraction可以实现各个事件的模拟，只需import iron-test-helpers.html 即可。使用方法如下： `test(‘can be triggered with space’, function(done) { button.addEventListener(‘keydown’, function() { done(); }); MockInteractions.pressSpace(button);}); test(‘can be clicked’, function(done) { button.addEventListener(‘click’, function() { done(); }); MockInteractions.tap(button);});","categories":[{"name":"Uncategorized","slug":"Uncategorized","permalink":"https://mengbaby.github.io/categories/Uncategorized/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mengbaby.github.io/Mtags/javascript/"},{"name":"前端单元测试","slug":"前端单元测试","permalink":"https://mengbaby.github.io/Mtags/前端单元测试/"},{"name":"polymer","slug":"polymer","permalink":"https://mengbaby.github.io/Mtags/polymer/"},{"name":"unit test","slug":"unit-test","permalink":"https://mengbaby.github.io/Mtags/unit-test/"},{"name":"web components","slug":"web-components","permalink":"https://mengbaby.github.io/Mtags/web-components/"},{"name":"web-components-tester","slug":"web-components-tester","permalink":"https://mengbaby.github.io/Mtags/web-components-tester/"}]},{"title":"前端自动化测试基础-sinon篇章","slug":"f2e-testing-sion","date":"2015-12-26T05:10:16.000Z","updated":"2017-04-17T07:20:04.000Z","comments":true,"path":"2015/12/26/f2e-testing-sion/","link":"","permalink":"https://mengbaby.github.io/2015/12/26/f2e-testing-sion/","excerpt":"","text":"sinon用途 在测试领域 Test double是很重要的一个概念。Test double主要用在自动化测试领域，会使用简单的对象或者流程模拟对应的行为减少测试的复杂性。 用于 JavaScript 的测试监视(spy)、桩(stub)和仿制(mock)功能。不依赖其他类库，兼容任何单元测试框架。 sinon spy（最常用） test spy 是这样的一类函数，它可以记录自己被调用的情况，包括传入的参数、返回结果、this 指向和抛出的错误（如果有的话）。test spy 可以是一个匿名函数，也可以是对一个已有函数进行的封装。 用于测试callback函数 用于spy已知行为的方法 创建spy 12345//创建一个匿名的函数用于记录调用的参数、返回值、以及异常var spy = sinon.spy();var spy = sinon.spy(myFunc);//对对象的方法增加spy 用于替换原有方法的行为，可以通过调用object.method.restore()实现恢复设置var spy = sinon.spy(object, \"method\"); sinon API用法 判断某函数调用了某些参数：spy.withArgs(arg1[, arg2, …]); e.g. assert(spy.withArgs(42).calledOnce); 某函数调用的次数：spy.callCount spy.called spy.calledTwice spy.calledThrice spy.firstCall spy.secondCall spy.thirdCall 判断是否在另一个spy之前（后）被调用 spy.calledBefore(anotherSpy);spy.calledAfter(anotherSpy); 至少有一次被某个参数调用，参数可以部分匹配：spy.calledWith(arg1, arg2, …); 至少有一次抛出异常：spy.threw(); sinon spy实例 123456789101112131415161718//以backbone的Event单测为例var eventer = _.extend(&#123;&#125;, Backbone.Events), spy = sinon.spy();// Set up the spy.eventer.on(\"foo\", spy);expect(spy.called).to.be.false;// Fire event.eventer.trigger(\"foo\", 42);// Check number of calls.expect(spy.calledOnce).to.be.true;expect(spy.callCount).to.equal(1);// Check calling arguments.expect(spy.firstCall.args[0]).to.equal(42);expect(spy.calledWith(42)).to.be.true; sinon stub stub（桩）其实是最抽象最难理解的，Test stubs是一类预编码行为的函数（也是一种 spy）。除了改变stub对象的行为之外，它还支持所有的 spy API。同spy一样，stubs 可以是匿名函数，或者包装已有函数。当使用 stub 包装一个已有函数时，原函数将不会被调用。 stub用于： 在测试中控制一个方法的行为，以强制代码沿特定路径执行。例如测试错误处理时，可以强制一个方法抛出错误。 当你希望阻止一个方法被直接调用时（可能是因为这个方法触发了干扰行为，例如 XHR 请求之类的）。 创建stub 创建一个匿名的 stub 函数。var stub = sinon.stub(); 使用一个 stub 函数替代 object.method。原函数可以通过调用 object.method.restore() （或 stub.restore()）方法来还原。如果 object.method 不是一个函数，则会抛出一个异常来帮助你避免类型错误。var stub = sinon.stub(object, “method”); 使用 func 来替换 object.method，并且被包装在一个 spy 中。object.method.restore() 可以恢复原方法。var stub = sinon.stub(object, “method”, func); stub 该对象的所有方法。var stub = sinon.stub(obj); stub API，详情 stub.withArgs(arg1[, arg2, …]); stub.returns(obj); stub.throws(); 例： var callback = sinon.stub(); callback.withArgs(1).throws(“TypeError”); stub.yieldsTo(property, [arg1, arg2, …]) sinon stub实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//basic usage var obj = &#123; multiply: function (a, b) &#123; return a * b; &#125;, error: function (msg) &#123; throw new Error(msg); &#125; &#125;; it(\"stubs multiply\", function () &#123; // Stub with a hard-coded return value. sinon.stub(obj, \"multiply\").returns(5); expect(obj.multiply(1, 2)).to.equal(5); obj.multiply.restore(); // Stub with a function. sinon.stub(obj, \"multiply\", function (a, b) &#123; return a + b; &#125;); expect(obj.multiply(1, 2)).to.equal(3); obj.multiply.restore(); &#125;); it(\"stubs error\", sinon.test(function () &#123; this.stub(obj, \"error\"); expect(obj.error).to.not.throw(); &#125;)); &#125;);//use yieldsTo it(\"stubs with yieldsTo\", function () &#123; var obj = &#123; async: function (opts) &#123; opts.success(\"a\", \"b\"); &#125; &#125;, spyObj = &#123; failure: sinon.spy(), success: sinon.spy() &#125;; sinon.stub(obj, \"async\").yieldsTo(\"success\", 1, 2); // Call on object with callback spies. obj.async(spyObj); expect(spyObj.failure).to.have.not.have.been.called; expect(spyObj.success) .to.have.been.calledOnce.and .to.have.been.calledWith(1, 2); &#125;); ##sinon mock 用于给出expectation然后验证某个object的method是否是正确的 同spy的区别，mock出的object收到了数据或是调用并没有真正执行，一切针对mock的调用都是假的。所以mock可以用来测试具有side effect的函数，这里的side effect泛指和外部对象有数据交互或者是调用，比如调用外部对象的方法、向server发送数据、和UI对象有交互、写日志等等。 API 创建mock：var mock = sinon.mock(obj); 给出expectation mock.expects(“method”); 校验是否正确： mock.verify(); 重置：mock.restore(); sinon mock 例子 123456789101112131415161718192021222324252627282930describe(\"Sinon.JS mocks\", function () &#123; // Object literal with two methods. var obj = &#123; multiply: function (a, b) &#123; return a * b; &#125;, error: function (msg) &#123; throw new Error(msg); &#125; &#125;; it(\"mocks multiply\", function () &#123; // Create the mock. var mock = sinon.mock(obj); // The multiply method is expected to be called: mock.expects(\"multiply\") .atLeast(2) // 2+ times, .atMost(4) // no more than 4 times, and .withArgs(2); // 2 was first arg on *all* calls. // Make 3 calls to `multiply()`. obj.multiply(2, 1); obj.multiply(2, 2); obj.multiply(2, 3); // Verify **all** of the previous expectations. mock.verify(); // Restore the object. mock.restore(); &#125;);&#125;); sinon Fake XMLHttpRequest/ Fake Server fake server用法 123456789101112131415161718192021&#123; setUp: function () &#123; this.server = sinon.fakeServer.create();//创建server &#125;, tearDown: function () &#123; this.server.restore(); &#125;, \"test should fetch comments from server\" : function () &#123; this.server.respondWith(\"GET\", \"/some/article/comments.json\", [200, &#123; \"Content-Type\": \"application/json\" &#125;, '[&#123; \"id\": 12, \"comment\": \"Hey there\" &#125;]']); var callback = sinon.spy(); myLib.getCommentsFor(\"/some/article\", callback); this.server.respond(); sinon.assert.calledWith(callback, [&#123; id: 12, comment: \"Hey there\" &#125;]); &#125;&#125; sinon可以用作实现request的模拟，现在更多的使用supertest用于HTTP的测试 123456789101112131415describe('GET /user', function()&#123; it('user.name should be an case-insensitive match for \"tobi\"', function(done)&#123; request(app) .get('/user') .set('Accept', 'application/json') .expect(function(res) &#123; res.body.id = 'some fixed id'; res.body.name = res.body.name.toUpperCase(); &#125;) .expect(200, &#123; id: 'some fixed id', name: 'TOBI' &#125;, done); &#125;);&#125;); sinon 测试代码","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://mengbaby.github.io/categories/nodejs/"},{"name":"testing","slug":"nodejs/testing","permalink":"https://mengbaby.github.io/categories/nodejs/testing/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mengbaby.github.io/Mtags/javascript/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://mengbaby.github.io/Mtags/自动化测试/"},{"name":"sinon","slug":"sinon","permalink":"https://mengbaby.github.io/Mtags/sinon/"}]},{"title":"响应式设计的自动化测试","slug":"f2e-testing-responsive","date":"2015-11-21T23:26:47.000Z","updated":"2017-04-17T07:19:28.000Z","comments":true,"path":"2015/11/22/f2e-testing-responsive/","link":"","permalink":"https://mengbaby.github.io/2015/11/22/f2e-testing-responsive/","excerpt":"","text":"响应式设计介绍响应式设计（RWD）从2010年开始就逐渐进入人们的视线，虽然由于网速和网络的制约，目前国内都是采用针对pc和移动分别开发站点的策略，例如淘宝网的首页在pc端网页 ，在移动端的网页为网页，使用的是基于REM的布局设计。但是没人能否认响应式设计的重要性和简便性。响应式设计其实简单来说就是利用media query针对不同的设备和分辨率采用不同的css样式，用以达到网站在各个设备上的兼容性，再结合“移动优先”的策略，使得响应式设计更加的具有优势。 一个响应式设计的实现下面就举一个简单的响应式网站的例子。代码见f2e-testing 首页welcome页面 登陆页面 notes列表页面 新建note页面 公共头尾和菜单的响应式实现这个属于很经典的响应式菜单和标题设计： 首页中如果是mobile或者ipad 则只显示标题的主要部分 菜单中如果是大屏，则一行显示菜单，mobile下用两行的菜单 css完整实现：参见 123456&lt;div id=\"header\"&gt; &lt;div class=\"middle-wrapper\"&gt; &lt;img id=\"header-logo\" src=\"../src/assets/header-icon.png\"&gt; &lt;h1&gt; Sample Website &lt;span class=\"not-on-mobile not-on-tablet\"&gt;for Galen Framework&lt;/span&gt;&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344#menu &#123; background: url(\"images/menu-background.png\"); margin: 0; color: white;&#125;#menu ul &#123; margin: 0; padding: 0; list-style: none;&#125;#menu li &#123; display: inline-block;&#125;#menu ul:after &#123; clear: both;&#125;#menu li a &#123; min-width: 100px; font-size: 1.2em; color: white; padding: 20px; display: inline-block;&#125;@media (max-width: 500px) &#123; .not-on-mobile &#123; display: none; &#125; #menu &#123; width: 100%; &#125; #menu li &#123; width: 49%; &#125; #menu li a &#123; width: 100%; &#125;&#125;@media (max-width: 800px) &#123; .not-on-tablet &#123; display: none; &#125;&#125; welcome页面welcome页面：使用的是bootstrap的jumbotron的布局,这款响应式布局主要用在simple marketing or informational website。它具有一个通知的大型“布告栏”（jumbotron）和三栏式布局。主要的实现代码： 12345678910111213141516&lt;div class=\"middle-wrapper\"&gt; &lt;div id=\"content\"&gt; &lt;div id=\"welcome-page\" class=\"jumbotron\"&gt; &lt;h1&gt;Welcome to our test page!&lt;/h1&gt; &lt;p&gt;This app is used as a playground for &lt;a href=\"http://galenframework.com/\"&gt;Galen Framework&lt;/a&gt;&lt;/p&gt; &lt;p&gt; &lt;button class=\"btn btn-lg btn-primary button-login\" type=\"button\" onclick=\"App.showLoginPage();\"&gt; Login &lt;/button&gt; &lt;/p&gt; &lt;p&gt;To log in this website use the email &lt;b&gt;testuser@example.com&lt;/b&gt; and password &lt;b&gt;test123&lt;/b&gt; &lt;/p&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344.jumbotron &#123; padding: 30px; margin-bottom: 30px; color: inherit; background-color: #eee;&#125;.jumbotron h1,.jumbotron .h1 &#123; color: inherit;&#125;.jumbotron p &#123; margin-bottom: 15px; font-size: 21px; font-weight: 200;&#125;.container .jumbotron &#123; border-radius: 6px;&#125;.jumbotron .container &#123; max-width: 100%;&#125;//大于768px@media screen and (min-width: 768px) &#123; .jumbotron &#123; padding-top: 48px; padding-bottom: 48px; &#125; .container .jumbotron &#123; padding-right: 60px; padding-left: 60px; &#125; .jumbotron h1, .jumbotron .h1 &#123; font-size: 63px; &#125;&#125;@media (max-width: 500px) &#123; button &#123; width: 100%; margin-top: 10px; &#125;&#125; login登陆页面![] (http://gtms03.alicdn.com/tps/i3/TB1zvDUKpXXXXXvXpXXkao1KVXX-359-598.jpg)![] (http://gtms04.alicdn.com/tps/i4/TB1ZwPVKpXXXXanXpXXCIO.HpXX-1135-533.jpg) 12345678910@media (min-width: 501px) &#123; .dialog-panel &#123; width: 400px; border: 1px solid #ccc; padding: 20px; margin: auto; border-radius: 10px; box-shadow: 1px 3px 3px #ddd; &#125;&#125; 响应式兼容尺寸 合理的使用viewport 1234&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;&lt;!--或者使用如下的 --&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\"&gt; 使用hack兼容低版本浏览器的media query 1234567&lt;!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries --&gt;&lt;!-- WARNING: Respond.js doesn't work if you view the page via file:// --&gt;&lt;!--[if lt IE 9]&gt;&lt;script src=\"https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js\"&gt;&lt;/script&gt;&lt;script src=\"https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 参考bootstrap 3 它优先使用“移动优先”原则，详情：参考 Extra small devices ~ Phones (&lt; 768px) col-xs- Small devices ~ Tablets (&gt;= 768px) col-sm- Medium devices ~ Desktops (&gt;= 992px) col-md- Large devices ~ Desktops (&gt;= 1200px) col-lg- 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*========== Mobile First Method ==========*//* RWD is – Desktop -&gt; Tablet -&gt; Mobile *//* Mobile First RWD is – Mobile -&gt; Tablet -&gt; Desktop *//* Custom, iPhone Retina */@media only screen and (min-width : 320px) &#123;&#125;/* Extra Small Devices, Phones */@media only screen and (min-width : 480px) &#123;&#125;/* Small Devices, Tablets */@media only screen and (min-width : 768px) &#123;&#125;/* Medium Devices, Desktops */@media only screen and (min-width : 992px) &#123;&#125;/* Large Devices, Wide Screens */@media only screen and (min-width : 1200px) &#123;&#125;/*========== Non-Mobile First Method ==========*//* Large Devices, Wide Screens */@media only screen and (max-width : 1200px) &#123;&#125;/* Medium Devices, Desktops */@media only screen and (max-width : 992px) &#123;&#125;/* Small Devices, Tablets */@media only screen and (max-width : 768px) &#123;&#125;/* Extra Small Devices, Phones */@media only screen and (max-width : 480px) &#123;&#125;/* Custom, iPhone Retina */@media only screen and (max-width : 320px) &#123;&#125; 响应式设计的自动化测试框架 - galenframework介绍 用于响应式设计的开源UI自动化测试框架 测试spec “语义化友好”，通过位置信息准确定位各个元素的位置 测试用例API兼容java和javascript pc端和无线端多尺寸兼容，支持selenium appium saucelab browserstack多服务器测试 可自定义输出的测试 html report 安装 下载二进制代码 执行 ./install.sh galen -v 显示如下命令行 表明安装成功 123Galen FrameworkVersion: 2.1.2JavaScript executor: Rhino 1.7 release 5 2015 01 29 测试环境建立 执行 galen config：生成config文件用于配置初始化文件，具体参数配置 详情参见 文件结构 tests文件夹：用于装载测试脚本 init.js: 用于配置测试的设备和尺寸 pages文件夹： ui自动化测试的Page Object页面 login.page.test.js（默认是以.test.js后缀作为测试文件，如果有特殊要求可以在config文件中配置） specs文件夹: 用于装载响应式设计的规则spec文件 common.spec文件： loginPage.spec文件等等 config文件：配置文件 reports目录：用于生成自动化测试的html结果 构建测试服务 appium作为mobile的测试服务器，android真机测试的服务搭建,参考 selenium作为pc端的测试服务器 1234#server端：8002端口启动三星galaxy SIII设备的测试服务器；8001端口启动IPAD模拟器；启动chromepc端的测试服务器node . -a 127.0.0.1 -p 8002 -U 4df752b06833bfd3 --browser-name Chrome --no-resetnode . -a 127.0.0.1 -p 8001 --command-timeout 50000 --no-resetselenium-standalone start #客户端：测试 并且测试完成后浏览器打开测试结果 Galen的命令行运行，参考 galen check：运行spec galen test： 运行测试用例 galen dump：生成可视化spec- 123456789101112131415161718192021222324galen test mytest01.test --htmlreport &quot;htmlreport-dir&quot; --testngreport &quot;report/testng.xml&quot; --jsonreport &quot;jsonreport-dir&quot; --parallel-tests 4 galen test tests/ --htmlreport reports galen check homepage.gspec --url &quot;http://example.com&quot; --size &quot;640x480&quot; --javascript &quot;some.js&quot; --include &quot;mobile,all&quot; --exclude &quot;toexclude&quot; --htmlreport &quot;htmlreport-dir&quot; --testngreport &quot;report/testng.xml&quot; --jsonreport &quot;jsonreport-dir&quot;galen dump &quot;specs/homepage.gspec&quot; --url &quot;http://galenframework.com&quot; --size &quot;1024x768&quot; --export &quot;dumps/homepage-dump&quot; --max-width &quot;200&quot; --max-height &quot;200&quot; 测试流程 createGridDriver建立对服务器的链接,并启动driver12345678910111213var driver = createGridDriver('http://127.0.0.1:8001/wd/hub',&#123; desiredCapabilities: &#123; browserName: 'Safari', 'platformVersion': '9.1', 'platformName': 'iOS', 'app': 'safari', deviceName:\"iPad Air\", size: '600x800', safariInitialUrl: 'about:blank' &#125; &#125;)；driver.get(\"http://test.xxxxx.com\"); checkLayout连接spec文件和.test.js测试文件 编写测试脚本 编写spec文件 检查spec文件是否符合预期 1234567//定义testtest(\"Simplest test\", function () &#123; // here goes a test code&#125;);//[] spec中 @on的tag名称checkLayout(driver, \"specs/welcomePage.spec\", ['desktop']); 使用 Page Object ModelPageObject在selenium中是常见的设计模式，它可以快速的将测试用例和测试主体相互分开，通过复用，减少代码；同时可以把测试过程变化的参数在统一的地方配置，减少改动的成本。关于 Page Object我会再开文介绍，这里只为大家介绍在galenframework中我们可以如何快捷的定义我们的PageObject，以登陆页为参考： $page(pageName, primaryFields, [ secondaryFields ]) 123456789101112131415161718this.LoginPage = $page(\"Login page\", &#123; email: \"input.email\", // css locator password: \"xpath: //input[@class='password']\", // xpath locator submitButton: \"id: submit\", // id locator load: function () &#123; this.open(\"http://example.com/login\"); return this.waitForIt(); &#125;, loginAs: function (userName, password) &#123; this.email.typeText(userName); this.password.typeText(password); this.submitButton.click(); &#125;&#125;);// now you can use it like thisvar loginPage = new LoginPage(driver).load();loginPage.loginAs(\"testuser@example.com\", \"password\"); 页面的webdriver操作函数参考 GalenPage.js 针对于$page这个对象 open 打开页面 waitForIt 等到primaryFields的元素都 wait({}).untilAll({}); 等 getAllLocators：把 findChild 定位元素 findChildren 批量定位元素 针对pageElement（primaryFields还有secondaryFields中的元素） attribute 获取属性 cssValue 获得css属性值 typeText input输入内容 click 点击按钮 clear 清空input getText 获得输入的内容 hover getWebElement findChild findChildren isDisplayed 元素是否展现 操作并输出到report中 logged(text, callback) loggedFunction(textExpression, callback) 1234567//$&#123;_1&#125; $&#123;_2&#125; 代表argumentsloggedFunction(\"Log-in as $&#123;_1&#125; with password $&#123;_2&#125;\", function (email, password) &#123; this.emailTextfield.typeText(email); this.passwordTextfield.typeText(password); this.submitButton.click(); &#125;); spec文件编写spec文件是用于描述元素css之间的各种关系，符合语义化的要求，详情 参考 定义Objects：@objects tags和sections：= Main section = 变量 @set import其他的spec文件规则：@import header.spec forEach Loop：循环 near - checks that object is located near another object below - checks that an element is located below other object above - checks that an element is located above other object left-of and right-of - checks that an element is located above other object inside - checks that object is located inside another object width - checks the width of object height - checks the height of object aligned - checks horizontal or vertical alignment of object with other objects on page text - checks the text that is visible on page text is - checks that text is exactly as expected text contains -checks element contains expected text text starts - element should start with expected text text ends - element should end with expected text text matches - verifies that text matches Java Regular Expression centered - checks that object is centered inside another object absent - checks that object is either missing on page or is not visible contains - checks that object visually contains other objects inside it on - checks that object is visually located on other object component - runs a subset of specs from another file within the given object context color-scheme - checks the color distribution in the given object area 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@objects search-panel id search-bar search-panel-input xpath //div[@id='search-bar']/input[@type='text'] search-panel-button css #search-bar a menu-item-* css #menu li a = Main section = @on * menu: height 70px @on mobile login-button: width 100px @on mobile, desktop menu: height 300 px @set commonHeaderMargin 10 to 20px contentMargin ~ 20px # Approximate = Header = header-icon: inside header $&#123;commonHeaderMargin&#125; top left textfield: near button 5 to 15px left # By top edge menu-item-1: aligned horizontally top menu-item-2 # iframe中定义spec @objects banner-frame css iframe#banner= Main section = banner-frame: component frame banner.spec # color scheme login-form: color-scheme 10% white, 4 to 5 % black, &lt; 30% #f845b7 # image menu-item-1: image file imgs/menu-item-1.png, error 4%, tolerance 80 # 循环 = Main section = @forEach [menu-item-*] as itemName, prev as previousItem $&#123;itemName&#125;: right-of $&#123;previousItem&#125; 10px @for [ 1, 2 ] as index menu-item-$&#123;index&#125;: above menu-item-$&#123;index + 2&#125; 0 to 5px 完整的例子 代码：参见ui-galen-test 报表：","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://mengbaby.github.io/categories/nodejs/"},{"name":"testing","slug":"nodejs/testing","permalink":"https://mengbaby.github.io/categories/nodejs/testing/"},{"name":"responsive design","slug":"nodejs/testing/responsive-design","permalink":"https://mengbaby.github.io/categories/nodejs/testing/responsive-design/"}],"tags":[{"name":"appium","slug":"appium","permalink":"https://mengbaby.github.io/Mtags/appium/"},{"name":"javascript","slug":"javascript","permalink":"https://mengbaby.github.io/Mtags/javascript/"},{"name":"css3","slug":"css3","permalink":"https://mengbaby.github.io/Mtags/css3/"},{"name":"galenframework","slug":"galenframework","permalink":"https://mengbaby.github.io/Mtags/galenframework/"},{"name":"responsive design","slug":"responsive-design","permalink":"https://mengbaby.github.io/Mtags/responsive-design/"},{"name":"UI自动化测试","slug":"UI自动化测试","permalink":"https://mengbaby.github.io/Mtags/UI自动化测试/"},{"name":"响应式设计","slug":"响应式设计","permalink":"https://mengbaby.github.io/Mtags/响应式设计/"}]},{"title":"前端自动化测试基础-断言篇：chai和chai插件的用法","slug":"f2e-testing-assert","date":"2015-11-11T06:32:50.000Z","updated":"2017-04-17T07:46:39.000Z","comments":true,"path":"2015/11/11/f2e-testing-assert/","link":"","permalink":"https://mengbaby.github.io/2015/11/11/f2e-testing-assert/","excerpt":"","text":"chai概念 测试技术的断言框架。 特点 支持多种BDD/TDD断言语法 BDD：should BDD：expect TDD：assert 可用在browser端和node端。 可以和很多测试框架结合例如mocha jasmine等进行单元和UI测试。 安装1npm install chai 用法browser端12345&lt;script src=\"//cdn.bootcss.com/chai/3.4.0/chai.js\"&gt;&lt;/script&gt;&lt;script&gt; //expect为全局的函数 expect(foo).to.not.equal('bar');&lt;/script&gt; node端123var chai = require('chai'), expect = chai.expect;chai.should(); expect用法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215//------------------ 连接词用法 -----------------//not用法 expect().not.to.expect(foo).to.not.equal('bar');expect(goodFn).to.not.throw(Error);expect(&#123; foo: 'baz' &#125;).to.have.property('foo').and.not.equal('bar');//deep用法 expect(foo).to.deep. 通常和equal连用，判断object的相等需要用deepexpect(foo).to.deep.equal(&#123; bar: 'baz' &#125;);//any用法 用在keys的判断上expect(&#123; foo: 1, bar: 2 &#125;).to.have.any.keys('foo', 'baz');// all用法 用在keys的判断上expect(foo).to.have.all.keys('bar', 'baz');expect(&#123; foo: 1, bar: 2 &#125;).to.have.all.keys(['bar', 'foo']);//a 判断typeof 或者 language chain// typeofexpect('test').to.be.a('string');expect(&#123; foo: 'bar' &#125;).to.be.an('object');expect(null).to.be.a('null');expect(undefined).to.be.an('undefined');// language chainexpect(foo).to.be.an.instanceof(Foo);//---------------------判断bool----------------------//bool// 1 truthyexpect('everthing').to.be.ok;expect(1).to.be.ok;expect(false).to.not.be.ok;expect(undefined).to.not.be.ok;expect(null).to.not.be.ok;//2 trueexpect(true).to.be.true;expect(1).to.not.be.true;//3 falseexpect(false).to.be.false;expect(0).to.not.be.false;//4 nullexpect(null).to.be.null;expect(undefined).not.to.be.null;// 5 undefinedexpect(undefined).to.be.undefined;expect(null).to.not.be.undefined;//6 existvar foo = 'hi' , bar = null , baz;expect(foo).to.exist;expect(bar).to.not.exist;expect(baz).to.not.exist;//7 exptyexpect([]).to.be.empty;expect('').to.be.empty;expect(&#123;&#125;).to.be.empty;//------------------------判断函数参数---------------------------// argumentsfunction test () &#123; expect(arguments).to.be.arguments;&#125;//------------------------判断相等和大小关系--------------------------------// equal if the deep flag is set, // attention: asserts that the target is deeply equal to value.expect('hello').to.equal('hello');expect(42).to.equal(42);expect(1).to.not.equal(true);expect(&#123; foo: 'bar' &#125;).to.not.equal(&#123; foo: 'bar' &#125;);expect(&#123; foo: 'bar' &#125;).to.deep.equal(&#123; foo: 'bar' &#125;);// eql: 判断值等expect(&#123; foo: 'bar' &#125;).to.eql(&#123; foo: 'bar' &#125;);expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);//.above：大于expect(10).to.be.above(5);expect('foo').to.have.length.above(2);expect([ 1, 2, 3 ]).to.have.length.above(2);//least 至少expect('foo').to.have.length.of.at.least(2);expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);//below 低于expect(5).to.be.below(10);expect('foo').to.have.length.below(4);expect([ 1, 2, 3 ]).to.have.length.below(4);//most 最大为expect(5).to.be.at.most(5);expect('foo').to.have.length.of.at.most(4);expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);//.within(start, finish)在什么区间内expect(7).to.be.within(5,10);expect('foo').to.have.length.within(2,4);expect([ 1, 2, 3 ]).to.have.length.within(2,4);//.closeTo(expected, delta)expect(1.5).to.be.closeTo(1, 0.5);//------------------正则---------------//match(regexp)expect('foobar').to.match(/^foo/);//-----------------字符串-------------//string 判断含有某字符串expect('foobar').to.have.string('bar');//----------------throw---------------var err = new ReferenceError('This is a bad function.');var fn = function () &#123; throw err; &#125;expect(fn).to.throw(ReferenceError);expect(fn).to.throw(Error);expect(fn).to.throw(/bad function/);expect(fn).to.not.throw('good function');expect(fn).to.throw(ReferenceError, /bad function/);expect(fn).to.throw(err);expect(fn).to.not.throw(new RangeError('Out of range.'));//------------------------object相关判断-------------------------//deep &amp; property属性expect(foo).to.deep.equal(&#123; bar: 'baz' &#125;);expect(&#123; foo: &#123; bar: &#123; baz: 'quux' &#125; &#125; &#125;).to.have.deep.property('foo.bar.baz', 'quux');// typeofexpect('test').to.be.a('string');expect(&#123; foo: 'bar' &#125;).to.be.an('object');expect(null).to.be.a('null');expect(undefined).to.be.an('undefined');// language chainexpect(foo).to.be.an.instanceof(Foo);// includeexpect([1,2,3]).to.include(2);expect('foobar').to.contain('foo');expect(&#123; foo: 'bar', hello: 'universe' &#125;).to.include.keys('foo');// members 判断数组成员expect([1, 2, 3]).to.include.members([3, 2]);expect([1, 2, 3]).to.not.include.members([3, 2, 8]);expect([4, 2]).to.have.members([2, 4]);expect([5, 2]).to.not.have.members([5, 2, 1]);expect([&#123; id: 1 &#125;]).to.deep.include.members([&#123; id: 1 &#125;]);//respondTo(method) 判断是否是原型方法Klass.prototype.bar = function()&#123;&#125;;expect(Klass).to.respondTo('bar');expect(obj).to.respondTo('bar');Klass.baz = function()&#123;&#125;;expect(Klass).itself.to.respondTo('baz');//itself和respondTo结合起来判断是否是原型链的方法还是自身的方法function Foo() &#123;&#125;Foo.bar = function() &#123;&#125;Foo.prototype.baz = function() &#123;&#125;expect(Foo).itself.to.respondTo('bar');expect(Foo).itself.not.to.respondTo('baz');//change 判断函数是否改变了对象的属性值var obj = &#123; val: 10 &#125;;var fn = function() &#123; obj.val += 3 &#125;;var noChangeFn = function() &#123; return 'foo' + 'bar'; &#125;expect(fn).to.change(obj, 'val');expect(noChangFn).to.not.change(obj, 'val')//increase(function) 函数是否升高了属性值var obj = &#123; val: 10 &#125;;var fn = function() &#123; obj.val = 15 &#125;;expect(fn).to.increase(obj, 'val');//.decrease(function) 函数是否降低了属性值var obj = &#123; val: 10 &#125;;var fn = function() &#123; obj.val = 5 &#125;;expect(fn).to.decrease(obj, 'val');//keys.判断是否object含有某项属性//Note, either any or all should be used in the assertion. If neither are used, the assertion is defaulted to all.expect(&#123; foo: 1, bar: 2 &#125;).to.have.any.keys('foo', 'baz');expect(&#123; foo: 1, bar: 2 &#125;).to.have.any.keys('foo');expect(&#123; foo: 1, bar: 2 &#125;).to.contain.any.keys('bar', 'baz');expect(&#123; foo: 1, bar: 2 &#125;).to.contain.any.keys(['foo']);expect(&#123; foo: 1, bar: 2 &#125;).to.contain.any.keys(&#123;'foo': 6&#125;);expect(&#123; foo: 1, bar: 2 &#125;).to.have.all.keys(['bar', 'foo']);expect(&#123; foo: 1, bar: 2 &#125;).to.have.all.keys(&#123;'bar': 6, 'foo', 7&#125;);expect(&#123; foo: 1, bar: 2, baz: 3 &#125;).to.contain.all.keys(['bar', 'foo']);expect(&#123; foo: 1, bar: 2, baz: 3 &#125;).to.contain.all.keys([&#123;'bar': 6&#125;&#125;]); should用法同chai的差别详情参考123456var chai = require('chai');chai.should(); //语法： 基本是 expect().to.xx 相当于 ().should.xx **** foo.should.be.a('string'); //expect(foo).to.be.a('string'); foo.should.equal('bar'); //expect(foo).to.equal('bar'); //省略用法，见expect 注意：should在IE9下有问题 assertassert为TDD用法，现在一般都是用基于BDD的测试，所以省略，详情请参考 Assert chai as promise用法 将promise和chai结合起来，用于在某种异步的条件下形成的断言判断 attention： Chai as Promised is only compatible with modern browsers (IE ≥9, Safari ≥6, no PhantomJS) 具体用法：参见 12345678910111213141516171819202122232425262728293031323334353637doSomethingAsync().then( function (result) &#123; result.should.equal(\"foo\"); done(); &#125;, function (err) &#123; done(err); &#125;);//安装： npm install chai-as-promised//引用chai as promise后可以写作 should.eventually.xxxvar chai = require(\"chai\");var chaiAsPromised = require(\"chai-as-promised\");chai.use(chaiAsPromised);var should = chai.should();return doSomethingAsync().should.eventually.equal(\"foo\");//在ui测试中可以写作return driver.getAttribute(input, 'type').should.eventually.equal(fieldModel.type);return promise.should.be.fulfilled;return promise.should.eventually.deep.equal(\"foo\");return promise.should.become(\"foo\"); // same as `.eventually.deep.equal`return promise.should.be.rejected;return promise.should.be.rejectedWith(Error); // other variants of Chai's `throw` assertion work too.// 通过覆盖chaiAsPromised.transferPromiseness方法将assertion赋予then的链式调用功能// 应用例子 wd.js中 chaiAsPromised.transferPromiseness = wd.transferPromiseness;chaiAsPromised.transferPromiseness = function (assertion, promise) &#123; assertion.then = promise.then.bind(promise); // this is all you get by default assertion.finally = promise.finally.bind(promise); assertion.done = promise.done.bind(promise);&#125;; sinon-chai用法 sinon-chai 用于对Sinon.JS中的spy, stub, and mocking framework进行断言 具体用法，参见 API为： Sinon.JS property/method Sinon–Chai assertion called spy.should.have.been.called callCount spy.should.have.callCount(n) calledOnce spy.should.have.been.calledOnce calledTwice spy.should.have.been.calledTwice calledThrice spy.should.have.been.calledThrice calledBefore spy1.should.have.been.calledBefore(spy2) calledAfter spy1.should.have.been.calledAfter(spy2) calledWithNew spy.should.have.been.calledWithNew alwaysCalledWithNew spy.should.always.have.been.calledWithNew calledOn spy.should.have.been.calledOn(context) alwaysCalledOn spy.should.always.have.been.calledOn(context) calledWith spy.should.have.been.calledWith(…args) alwaysCalledWith spy.should.always.have.been.calledWith(…args) calledWithExactly spy.should.have.been.calledWithExactly(…args) alwaysCalledWithExactly spy.should.always.have.been.calledWithExactly(…args) calledWithMatch spy.should.have.been.calledWithMatch(…args) alwaysCalledWithMatch spy.should.always.have.been.calledWithMatch(…args) returned spy.should.have.returned(returnVal) alwaysReturned spy.should.have.always.returned(returnVal) threw spy.should.have.thrown(errorObjOrErrorTypeStringOrNothing) alwaysThrew spy.should.have.always.thrown(errorObjOrErrorTypeStringOrNothing) 1234567891011121314151617181920//安装 npm install sinon-chai//用法var chai = require(\"chai\");var sinonChai = require(\"sinon-chai\");chai.should();chai.use(sinonChai);function hello(name, cb) &#123; cb(\"hello \" + name);&#125;describe(\"hello\", function () &#123; it(\"should call callback with correct greeting\", function () &#123; var cb = sinon.spy(); hello(\"foo\", cb); cb.should.have.been.calledWith(\"hello foo\"); //if expect expect(cb).to.have.been.calledWith(\"hello foo\"); &#125;);&#125;); chai和mocha结合的测试用例 browser端：点击 node端: chai-should.js chai-expect.js","categories":[{"name":"javascript","slug":"javascript","permalink":"https://mengbaby.github.io/categories/javascript/"},{"name":"testing","slug":"javascript/testing","permalink":"https://mengbaby.github.io/categories/javascript/testing/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mengbaby.github.io/Mtags/javascript/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://mengbaby.github.io/Mtags/自动化测试/"},{"name":"chai","slug":"chai","permalink":"https://mengbaby.github.io/Mtags/chai/"},{"name":"mocha","slug":"mocha","permalink":"https://mengbaby.github.io/Mtags/mocha/"},{"name":"chai as promise","slug":"chai-as-promise","permalink":"https://mengbaby.github.io/Mtags/chai-as-promise/"},{"name":"ui测试","slug":"ui测试","permalink":"https://mengbaby.github.io/Mtags/ui测试/"},{"name":"单元测试","slug":"单元测试","permalink":"https://mengbaby.github.io/Mtags/单元测试/"},{"name":"断言","slug":"断言","permalink":"https://mengbaby.github.io/Mtags/断言/"}]},{"title":"Appium的源码编译安装","slug":"appium-install","date":"2015-10-22T01:08:14.000Z","updated":"2017-04-17T05:59:55.000Z","comments":true,"path":"2015/10/22/appium-install/","link":"","permalink":"https://mengbaby.github.io/2015/10/22/appium-install/","excerpt":"","text":"Appium是现在比较活跃的开源自动化测试平台，因为更新速度很快，建议编译安装，了解其更多有意思的功能。Appium支持ios android selendroid的自动化测试。在mac下配置ios环境还是相对简单的，但是android真机的配置就不是那么简单了，在此详细记录基于源码的编译安装。 准备工作 node git clone https://github.com/appium/appium.git 安装好node环境（brew安装最好） 安装 mocha 和grunt-cli 12npm install -g mochanpm install -g grunt-cli android真机配置因为android虚拟器跑起来非常慢，如果不是专业的android的开发，安装跑andorid studio环境也没有必要有对应的apk和sdk使用真机就能跑我们的测试脚本了。 准备工作： 安装java jdk 配置JAVA_HOME 安装android jdk，可以在线安装（国内速度超慢），所以快捷的方式是下载adt-bundle，解压后直接可用，下载地址 配置ANDROID_HOME 环境变量的配置代码见下方: 执行环境检测 bin/appium-doctor.js –android 出现如下结果证明android环境配置成功 12345678# ~/.bash_profile的配置内容# 修改完之后source ~/.bash_profile生效export ANDROID_HOME=/Users/zhangmeng/Documents/adt-bundle-mac-x86_64-20131030/sdkexport PATH=/Users/zhangmeng/Documents/adt-bundle-mac-x86_64-20131030/sdk/platform-tools:$PATHexport PATH=/Users/zhangmeng/Documents/adt-bundle-mac-x86_64-20131030/sdk/tools:$PATHexport JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Homeexport PATH=$JAVA_HOME/bin:$PATH 配置手机 开启开发者选项，设置-{}开发者选项，如果没有找到，参考 打开USB调试（如下图） 部分手机需要在 连接USB的时候选用 MTP媒体模式才会生效 在命令行执行如下指令，能够列出后（如果不行, 重新插拔一下usb，还可以尝试方法） 12adb kill-serveradb devices 其中list出来的就是手机的udid，用于后面的测试使用，如下图 执行初始化脚本按照上面的步骤执行完成之后，运行命令./reset.sh –andorid –verbose即可。在没有读这个reset.sh脚本的时候真的是被各种的环境搞的头晕脑胀，各种报错，包括：基本都是有命令运行不通造成的，所以在这里大概介绍一下在appium reset android中的到底做了些什么，帮助大家理解这个启动脚本，以便配合自己的应用解决编译的问题，这个也是源码编译的好处之一，可以及时的解决更新服务。 android API 不匹配 Device chrome not configured yet uninstall io.appium.android.ime卡住不再运行 reset.sh分析12345678910111213141516171819202122reset_android() &#123; echo &quot;RESETTING ANDROID&quot; require_java echo &quot;* Configuring Android bootstrap&quot; run_cmd rm -rf build/android_bootstrap run_cmd &quot;$grunt&quot; configAndroidBootstrap echo &quot;* Building Android bootstrap&quot; run_cmd &quot;$grunt&quot; buildAndroidBootstrap reset_unlock_apk reset_unicode_ime reset_settings_apk if $include_dev ; then reset_apidemos reset_toggle_test if $npmlink ; then link_appium_adb fi fi echo &quot;* Setting Android config to Appium&apos;s version&quot; run_cmd &quot;$grunt&quot; setConfigVer:android reset_chromedriver&#125; 配置Android bootstrap 删除下build/android_bootstrap目录 执行grunt configAndroidBootstrap：配置UiAutomation需要的编译文件 appium/lib/devices/android/bootstrap/build.xml project.properties local.properties 生成AppiumBootstrap的编译文件：用于运行 android create uitest-project -n AppiumBootstrap -t android-19 -p xx/appium/lib/devices/android/bootstrap/ 编译 Android bootstrap grunt buildAndroidBootstrap：使用ant编译AppiumBootstrap.jar，放置到appium/build/android_bootstrap/下 编译apk文件（build目录下） 编译 unlock apk: 唤醒和解锁andorid手机或是虚拟器详情 编译 unicode ime apk: android对ASCII码的支持不好，所以会安装这个utf7的输入法，将sendKeys中的输入转为unicode识别的编码，详情 编译 appium-settings apk:用于控制android系统 详情 如果开启了测试模式 –dev参数 编译sample-code下的app：ToggleTest apiDemos 更新 appium-adb模块：运行./bin/npmlink.sh -l appium-adb 更新appium的版本号 reset_chromedriver 详情参考 运行测试用例 node . -U 4df752b06833bfd3 （显示下面的提示证明Appium Server能够正常启动） 详细的运行参数参考 运行测试用例 : mocha wd-android-helloworld.js （wd.js） 其中支持原生的browser、chrome、还有apk的测试 12345678910111213141516171819202122var wd = require(\"wd\");var driver = wd.promiseChainRemote(&#123; host: 'localhost', port: 4723&#125;);driver .init(&#123; browserName: 'Chrome',//Chrome or Browser(原生，默认主页是google建议最好翻墙不然卡住) platformName: 'Android', platformVersion: '4.4.4', deviceName: 'Android Emulator' //,app: '/Users/zhangmeng/Downloads/com.taobao.taobao-5.3.1-121.apk' //如果选择测试app的内容 browserName设置为''; //执行app后会把对应的apk安装到真机中 &#125;) .get('http://www.baidu.com') .sleep(5000) .title().then(function (title)&#123; console.log('this is the website title', title) &#125;) .quit() .done(); ios 虚拟器配置配置和启动服务12345$ git clone https://github.com/appium/appium.git$ cd appium$ ./reset.sh --ios --verbose$ sudo ./bin/authorize-ios.js # for ios only 修改权限$ node . 测试脚本参见 safari-wd-search-test.js 参考 https://github.com/appium/appium/blob/master/docs/en/contributing-to-appium/appium-from-source.md https://github.com/appium/appium/blob/master/docs/en/contributing-to-appium/grunt.md http://university.utest.com/android-ui-testing-uiautomatorviewer-and-uiautomator/ http://developer.android.com/tools/help/shell.html","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://mengbaby.github.io/categories/nodejs/"},{"name":"testing","slug":"nodejs/testing","permalink":"https://mengbaby.github.io/categories/nodejs/testing/"}],"tags":[{"name":"android","slug":"android","permalink":"https://mengbaby.github.io/Mtags/android/"},{"name":"appium","slug":"appium","permalink":"https://mengbaby.github.io/Mtags/appium/"},{"name":"ios","slug":"ios","permalink":"https://mengbaby.github.io/Mtags/ios/"},{"name":"javascript","slug":"javascript","permalink":"https://mengbaby.github.io/Mtags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://mengbaby.github.io/Mtags/nodejs/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://mengbaby.github.io/Mtags/自动化测试/"}]},{"title":"前端自动化测试基础-mocha篇","slug":"f2e-testing-mocha","date":"2015-10-13T00:05:22.000Z","updated":"2017-04-17T07:16:45.000Z","comments":true,"path":"2015/10/13/f2e-testing-mocha/","link":"","permalink":"https://mengbaby.github.io/2015/10/13/f2e-testing-mocha/","excerpt":"","text":"安装1npm install -g mocha 命令行用法常用的命令行为： 1mocha -u bdd -R spec -t 5000 --recursive -u：测试方式 bdd|tdd|exports -R：选择报表的展现方式，报表展现方式，默认为spec，附加的 例如mocha-lcov-reporter（需要自己安装） -t：超时时间设置，当测试中有异步的时候如果超过设定时间会退出测试，默认2s –recursive：默认会把test文件夹和子文件夹中的所有的测试文件执行一遍 详解参考官网Usage describe it hook初次接触mocha的人，常常会觉得这几个概念很抽象,用简单的语言概括来说： describe:用于将测试分类，可以嵌套，范围从大到小 it：真正包裹测试断言的作用域 hook：before beforeEach after afterEach 为测试做辅助的作用域，例如 before中可以执行数据库的初始化，或者检测活动；after中用于清除使用的变量等。 mocha和BDD测试mocha支持bdd和tdd的测试，支持should/expect的断言方式,常和chai结合在一起使用 12345678910111213141516//npm install chai之后var chai = require('chai');var expect = chai.expect;var Person = function (name) &#123; this.name = name;&#125;;var zhangmeng = new Person('zhangmeng');describe('zhangmeng attribute', function () &#123; it ('zhangmeng should be a person ', function () &#123; expect(zhangmeng).to.be.an.instanceof(Person); &#125;)&#125;); 异步的处理在javascript的世界 测试异步程序是特别常见的，例如文件的读写、数据库的访问等等，mocha对异步的支持也特别好，你只需要在最里面的函数中增加对应的回调即可，此外mocha是支持promise的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * @fileOverView mocha-async-demo * @author zhangmeng on 15/10/12 *///使用异步callback的方式var fs = require('fs');var fileName = '/opt/local/share/nginx/html/my-git/f2e-testing/basic/files/name.json';var chai = require('chai');var expect = chai.expect;var Q = require('q');//使用回调的方式测试describe('file content validation through callback', function () &#123; //读取文件内容 var fileObj = &#123;&#125;; before(function (done) &#123; //async fs.readFile(fileName, 'utf-8', function (err, data) &#123; if (err) &#123; throw err; &#125; fileObj = JSON.parse(data); done(); &#125;); &#125;); it ('expect name to be zhangmeng', function () &#123; var name = fileObj.name; expect(name).to.equal(\"zhangmeng\"); &#125;); it ('expect name to be zhangmeng', function () &#123; var age = fileObj.age; expect(age).to.equal('29'); &#125;);&#125;);//使用promise的方式例子describe('file content validation through promise', function () &#123; var fileObj = &#123;&#125;; var readFilePromise = function(path, encoding) &#123; var encoding = encoding || 'utf-8'; var deferred = Q.defer(); fs.readFile(path, encoding, function(err, text) &#123; if(err) &#123; deferred.reject(new Error(err)); &#125; else &#123; deferred.resolve(text); &#125; &#125;); return deferred.promise; &#125;; before('read name.json', function () &#123; //return 支持promise的异步 return readFilePromise(fileName).then(function(data) &#123; try &#123; fileObj = JSON.parse(data); &#125; catch(err) &#123; console.log(err); &#125; &#125;) &#125;); it ('name should be zhangmeng', function () &#123; var name = fileObj.name; expect(name).to.equal('zhangmeng'); &#125;); it ('age should be 29', function () &#123; var age = fileObj.age; expect(age).to.equal('29'); &#125;);&#125;); 执行顺序关于it和hook之间的顺序，有时非常容易混淆，先上结论： beforeEach会对当前describe下的所有子case生效。 before和after的代码没有特殊顺序要求。 同一个describe下可以有多个before，执行顺序与代码顺序相同。 同一个describe下的执行顺序为before, beforeEach, afterEach, after（*），见下例。 当一个it有多个before的时候，执行顺序从最外围的describe的before开始，其余同理。 当没有it的时候，before还有beforeEach的内容都不会执行（*） it的内容是按照顺序执行的 即使前面的it的内容完成的时间偏后，也会按照顺序执行（*） 123456789101112131415161718192021222324252627describe('earth', function()&#123; beforeEach(function()&#123; console.log('see.. this function is run EACH time, before each describe()') &#125;) describe('singapre', function()&#123; before(function () &#123; console.log('it will happen before beforeEach and only once') &#125;) it('birds should fly', function()&#123; /** ... */ &#125;) it('horse should gallop', function()&#123; /** ... */ &#125;) &#125;) describe('malaysia', function()&#123; it('birds should soar', function()&#123; /** ... */ &#125;) &#125;)&#125;)//执行结果//earth//singapre//it will happen before beforeEach and only once//see.. this function is run EACH time, before each describe()//✓ birds should fly//see.. this function is run EACH time, before each describe()//✓ horse should gallop//malaysia//see.. this function is run EACH time, before each describe()//✓ birds should soar 源码 mocha与chai的结合 mocha执行顺序 mocha的异步（callback和promise） 复杂的mocha应用-express","categories":[{"name":"nodjs","slug":"nodjs","permalink":"https://mengbaby.github.io/categories/nodjs/"},{"name":"testing","slug":"nodjs/testing","permalink":"https://mengbaby.github.io/categories/nodjs/testing/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://mengbaby.github.io/Mtags/nodejs/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://mengbaby.github.io/Mtags/自动化测试/"},{"name":"前端","slug":"前端","permalink":"https://mengbaby.github.io/Mtags/前端/"},{"name":"bdd","slug":"bdd","permalink":"https://mengbaby.github.io/Mtags/bdd/"},{"name":"chai","slug":"chai","permalink":"https://mengbaby.github.io/Mtags/chai/"},{"name":"mocha","slug":"mocha","permalink":"https://mengbaby.github.io/Mtags/mocha/"},{"name":"异步","slug":"异步","permalink":"https://mengbaby.github.io/Mtags/异步/"}]},{"title":"前端UI自动化测试","slug":"f2e-testing-basic","date":"2015-10-07T22:41:01.000Z","updated":"2017-04-17T07:13:37.000Z","comments":true,"path":"2015/10/08/f2e-testing-basic/","link":"","permalink":"https://mengbaby.github.io/2015/10/08/f2e-testing-basic/","excerpt":"","text":"测试手段UI测试目前主要有方式： record-and-replay: 主要是指利用录制工具去记录用户的行为，并且把这种“行为“存储到脚本中，以便将来用于检测程序或应用是否能够产出预期的效果。常用的record-and-replay工具有：微软的RPF以及google早期出品的abite。 e2e测试(end-to-end testing)：这种测试方式不光可以测试UI层，还可以将整个系统的功能进行测试。通常这种测试会使用第三方的测试工具作为测试doubles层以提升测试效率。 测试内容没人可以否认UI测试是耗时且昂贵的，所以在写测试的时候一定要慎重的选择使用UI测试的case，下图就是一种比较“聪明”的UI测试架构。我们可以将UI层进行拆分：视图层还有UI逻辑层。如果大家知道 MVX 这种架构，就会知道，UI逻辑层更像是 MVX 中的Controller层和Model层，视图层是比较难以测试和描述的，因此不建议将对视图层的内容作为UI测试的重点，当然我们也可以使用简单的spec来描述视图层的内容，或是对于视图的样式等使用 galenframework类似的框架进行测试 (后面的blog会专门介绍这个框架，它脱离了phantomCss的检测方式，使用特殊的spec方式来描述case，对于前端来说，非常值得学习)。 因此我们更多的测试会围绕UI逻辑层进行。UI逻辑层主要的用途如下，因此我们的case就围绕着对这两部分功能的测试进行编写。 用户和浏览器的交互(操作和更新html) 监听html的事件并且将信息通过request传递给后台 测试框架UI测试框架主要由两部分构成：客户端的Test环境和测试服务，测试框架的基本原理很简单，本着经济有效的原则，设计了这款使用开源技术的UI测试框架，跨平台、支持多语言、且支持PC端和mobile端的测试方案，本人是前端，所以下例都是基于Nodejs/javascript书写。 UI测试服务端的构建 对于UI测试的服务端平台来说，非常欣赏BrowserStack这个测试平台。实时的、Web-based、多语言，多浏览器、多机型支持，API和接口全面丰富的基于云端的测试平台，除了价格比较贵（$39/month），绝对是最完的测试利器。 对于UI测试来说，浏览器宿主环境是非常重要的，而服务端的Hub架构就是通过代理服务器的方式帮你操纵各种类型的浏览器进行自动化测试。在此我们选择了selenium-standalone来实现pc端的server(内置Jetty服务器)；appium这个node服务器作为mobile端的server hub。 Selenium-standalone selenium-standalone支持node安装方式,通过下列脚本可以安装执行，同时可以配置对应的hub信息。 npm install selenium-standalone@latest -g selenium-standalone start – -role node -hub http://localhost:4444/grid/register -port 5556 selenium默认支持的浏览器为Firefox和phantom，如果要使用它操纵其他的浏览器参考如下方式安装对应驱动： chrome:selenium-standalone install –drivers.chrome.version=2.15 –drivers.chrome.baseURL=http://chromedriver.storage.googleapis.com safari：下载，并在safari中安装SafariDriver.safariextz插件 ie：selenium-standalone install –drivers.chrome.version=2.15 –drivers.chrome.baseURL=http://chromedriver.storage.googleapis.com Appium####简介mobile端的开发越来越火热，为了保证开发质量，也有很多针对移动端的测试工具应运而生。Appium就是其中很活跃的开源框架。本质上它包括两部分内容： 基于express的server用于发送/接收client端的协议命令 作为bootstrap客户端用于将命令传递给对应的UIAutomator/UIAutomation/Google’s Instrumentation Appium最大的特色就是支持ios/android/firefoxos多种平台的测试，native、h5、hybrid都支持，以及所有支持jsonWireProtocal协议的脚本语言：python，java，nodejs ruby都可以用来书写用例。 ####安装 因为Appium的社区发展的很快，建议使用源码编译使用，而不是使用AppiumGUI(它本身是由第三方社区维护，并不属于appium的核心产品 所以很多bug更新的并不及时，例如测试h5页面的时候页面会出现)，此外还可以根据自己的要求修改源码和调试，下面就简要介绍一下源码安装的方法, 安装详细方法 请见 Running Appium from Source： 配置IOS环境 xcode安装好 配置Andorid环境 java jdk 配置好并设置好JAVA_HOME android sdk安装并配置好ANDROID_HOME 建议在真机下进行测试（模拟器启动速度慢），参见executing_test_on_real_devices 运行下方代码 以IOS为例：编译安装并启动的结果如下： 12345git clone https://github.com/appium/appium.git cd appium ./reset.sh --verbose #感谢g*f*w 安装过程痛苦而漫长，使用--verbose显示日志吧，至少知道在哪里卡住 sudo ./bin/authorize-ios.js # for ios only modify /etc/authorization node . 如果需要详细的server启动配置，请参考Appium server arguments，例如 只想实现针对safari进行h5页面的自动化测试，配置参数为： 1node . --safari UI测试客户端框架前面提到了jsonWireProtcal协议，主要用于客户端的Testcase中定义对浏览器的操作，实现了这个协议的框架和语言有很多，这个大家自行选择。协议形如 GET /session/:sessionId/screenshotTake a screenshot of the current page. 个人比较欣赏wd.js这个框架，它是一个webdriver/selenium 2的node端实现，各种异步promise支持，自定义方法非常方便，同时支持mocha和chai的无缝嵌入。 简单用法 安装依赖 配置desirecapabilities,详细参数 操纵浏览器，API参加 API列表 详细代码参见github 12345678910111213141516var wd = require(\"wd\");var driver = wd.promiseChainRemote(&#123; protocol: 'http:', hostname: '127.0.0.1', port: '4444', path: '/wd/hub'&#125;);driver .init(&#123;browserName: 'safari'&#125;) .get('http://www.baidu.com') .sleep(5000) .title().then(function (title)&#123; console.log('this is the website title', title) &#125;) .quit(); chain和promise的写法将异步转化为Q chain的链式调用方式，内置Q支持自定义的promise,代码如下所示，详细代码见github 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @fileOverView wd-promise wd 链式调用实例 * @author zhangmeng on 15/10/4 */var wd = require(\"wd\");//内置Q chainvar Q = wd.Q;var browser = wd.promiseChainRemote(&#123; protocol: 'http:', hostname: '127.0.0.1', port: '4444', path: '/wd/hub'&#125;);/** * 自定义链式调用用于实现drag 和 drop的操作 * @param fromElm cssSelector * @param toElm cssSelector * @returns &#123;Function&#125; browser */var dragNdrop = function (fromElm, toElm) &#123; return function () &#123; return Q.all([ browser.elementByCssSelector(fromElm), browser.elementByCssSelector(toElm) ]).then(function (els) &#123; console.log(els); return browser .moveTo(els[0]) .buttonDown() .moveTo(els[1]) .buttonUp(); &#125;); &#125;&#125;;browser .init(&#123;browserName:'chrome'&#125;) .get('http://localhost:63342/my-git/f2e-testing/ui-wd-tests/test-html/test-dragNdrop.html') //chain link .then(dragNdrop('.dragable','.dropable')) .sleep(1000) .fin(function() &#123; return browser.quit(); &#125;) .done(); Asserter用法和自定义Asseterwd.js内置了基本的Asserter，同时支持自定义的断言。多数结合waitfor“句式“使用。这个在实际中经常应用，例如当页面中某个元素出现特定状态的时候去做某事，或者是判断某异步的加载完成的时候执行某操作等。 内置的判断包括 nonEmptyText isDisplayed isNotDisplayed textInclude jsCondition isVisible isHidden jsCondition(常用) waitfor包括： waitFor waitForElementByCss(elem, asserter, timeout, pollFreq, callback)（常用,判定当某元素存在，且满足某asserter的时候调用回调） waitForConditionInBrowser(jsExpression) 需要设置异步超时时间，setAsyncScriptTimeout 如果上述都不满足还可以自定义Asserter，下面是对应的例子，使用多种方法判断ajax加载完成后进行测试内容，详情见wd-asserter.js 12345678910111213141516171819202122232425//自定义方法var tableHasBeenLoaded = new Asserter( function(browser, cb) &#123; var jsConditionExpr = '($(\"#tbody tr\").length &gt; 0) ? true: false'; var _eval = browser.eval; _eval.apply( browser , [jsConditionExpr, function(err, res) &#123; if(err) &#123;return cb(err);&#125; cb(null, res, res); &#125;]); &#125;);browser .init(&#123;browserName: 'chrome'&#125;) .setAsyncScriptTimeout(30000) .get('http://localhost:63342/my-git/f2e-testing/ui-wd-tests/test-html/test-assert.html') //------------- case2 jsCondition waitForConditionInBrowser new Asserter waitForAjaxLoaded ----- .elementByCss('#getBtn') .click() //click to trigger ajaxloading //.waitFor(tableHasBeenLoaded, 4000) .execute('alert(\"ajax finished\")') .sleep(2000) .fin(function () &#123; return browser.quit(); &#125;) .done(); 自定义操作方法使用wd.PromiseChainWebdriver.prototype可以将自定义的方法chain到链式调用中去，同时还可以使用promise来实现，例如上面dragNdrop的例子 123456789101112//method1 of self-defined methodwd.PromiseChainWebdriver.prototype.waitForAjaxLoaded = function (timeout) &#123; //this为browser内容 return this.waitFor(tableHasBeenLoaded, timeout)&#125;//method2function selfDefinedFunction() &#123; return browser.xxxxx&#125;browser.init().get().selfDefinedFunction().xx 插入js代码在测试的实际应用中，经常需要引入需要的类库或者辅助代码来实现测试的目的，那么应该怎么操作呢，wd.js按照jsonWireProtocal是支持执行js代码的，一般通过下面两个方法。最常见的是要测的代码中是没有对应的类库的 如果要使用，例如jquery kissy，那么需要预先inject对应的代码，类似js bookmark书签，或者chrome的插件中的content_script代码。具体代码参见wd-jsinject.js execute()：执行同步代码 executeAsync()：执行的内容中含有异步的内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//load.js 用于load javascript类库var loadScript = function (scriptUrl, callback) &#123; var script = document.createElement('script'); var head = document.getElementsByTagName('head')[0]; var done = false; script.onload = script.onreadystatechange = (function() &#123; if (!done &amp;&amp; (!this.readyState || this.readyState == 'loaded' || this.readyState == 'complete')) &#123; done = true; script.onload = script.onreadystatechange = null; head.removeChild(script); callback(); &#125; &#125;); script.src = scriptUrl; head.appendChild(script);&#125;;loadScript = loadScript(arguments[0], arguments[arguments.length - 1]);//loadScript('//cdn.bootcss.com/jquery/2.1.4/jquery.js');//dom.js 判断类库是否正确引入，设置Fn = &#123;&#125;;var appendChild = setTimeout(function() &#123; $(\"#i_am_an_id\").append('&lt;div class=\"child\"&gt;I am the child&lt;/div&gt;')&#125;, arguments[0]);var removeChildren = function () &#123; $(\"#i_am_an_id\").empty();&#125;;Fn = &#123; appendChild: appendChild, removeChildren: removeChildren&#125;;//定义object方便链式操作中调用window.Fn = Fn;//wd-jsInject.jsvar jsFileToString = function (filePath) &#123; var file = fs.readFileSync(filePath, \"utf8\"); return file;&#125;;//读取本地的代码var codeUrl = '/opt/local/share/nginx/html/my-git/f2e-testing/ui-wd-tests/scripts/dom.js';//加载jquery等类库var loadUrl = '/opt/local/share/nginx/html/my-git/f2e-testing/ui-wd-tests/scripts/load.js';//读取js代码（自动转化为jsExpression）var executeStr = jsFileToString(codeUrl);var loadScriptStr = jsFileToString(loadUrl);browser .init(&#123;browserName:'chrome'&#125;) .get('http://localhost:63342/my-git/f2e-testing/ui-wd-tests/test-html/test-injectjs.html') //inject jquery .setAsyncScriptTimeout(30000) .executeAsync(loadScriptStr, [\"//cdn.bootcss.com/jquery/2.1.4/jquery.js\"]) .execute(executeStr) //测试jquery是否正常引入 .execute('Fn.appendChild', [1000]) .execute('Fn.removeChildren()') .sleep(2000) .fin(function() &#123; return browser.quit(); &#125;) .done(); 结合mocha和chaimocha是用于测试的框架，chai用于辅助断言，wd.js支持两者的无缝接入，可以使ui测试变得像单元测试一样简单。参考下面的demo，就是把三者结合在一起，通过wd对appium访问ios虚拟机，对手机淘宝搜索结果页进行UI测试的例子，代码详见Github F2E-testing UI test 1234567891011121314151617181920212223242526272829303132333435363738require('../helpers/setup');var wd = require(\"wd\");var serverConfig = require('../helpers/server').appium;var desired = require('../helpers/caps').ios90s;var begin_page_url = 'http://s.m.taobao.com/h5?search-btn=&amp;event_submit_do_new_search_auction=1&amp;_input_charset=utf-8&amp;topSearch=1&amp;atype=b&amp;searchfrom=1&amp;action=home%3Aredirect_app_action&amp;from=1';describe('test page of taobao search', function () &#123; this.timeout(300000); var driver; before(function () &#123; driver = wd.promiseChainRemote(serverConfig); require(\"../helpers/logger\").configure(driver);//显示日志 return driver.init(desired); &#125;); after(function () &#123; return driver.quit(); &#125;); //1打开淘宝搜索页面 //2点击搜索框 //3进入到搜索结果页面 it(\"should open iphone+6s search page\", function () &#123; var inputValue = 'iphone 6s'; return driver .get(begin_page_url) .sleep(1000) .waitForElementByName('q', 2000) .sendKeys(inputValue) .waitForElementByName('search') .tap() .sleep(5000) .eval('window.location.href') .should.eventually.include('q=iphone+6s') &#125;);&#125;);","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://mengbaby.github.io/categories/nodejs/"},{"name":"testing","slug":"nodejs/testing","permalink":"https://mengbaby.github.io/categories/nodejs/testing/"}],"tags":[{"name":"appium","slug":"appium","permalink":"https://mengbaby.github.io/Mtags/appium/"},{"name":"nodejs","slug":"nodejs","permalink":"https://mengbaby.github.io/Mtags/nodejs/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://mengbaby.github.io/Mtags/自动化测试/"},{"name":"selenium","slug":"selenium","permalink":"https://mengbaby.github.io/Mtags/selenium/"},{"name":"UI","slug":"UI","permalink":"https://mengbaby.github.io/Mtags/UI/"},{"name":"wd.js","slug":"wd-js","permalink":"https://mengbaby.github.io/Mtags/wd-js/"},{"name":"webdriver","slug":"webdriver","permalink":"https://mengbaby.github.io/Mtags/webdriver/"},{"name":"前端","slug":"前端","permalink":"https://mengbaby.github.io/Mtags/前端/"}]},{"title":"browserify和webpack快速配置入门教程","slug":"browserify-and-webpack","date":"2015-09-21T01:04:12.000Z","updated":"2017-04-17T06:05:28.000Z","comments":true,"path":"2015/09/21/browserify-and-webpack/","link":"","permalink":"https://mengbaby.github.io/2015/09/21/browserify-and-webpack/","excerpt":"","text":"随着前端的工程越来越复杂，快速的模块化构建、部署前端app也就变得更加的重要，最近比较火爆的工具有browserify和webpack。真的是非常好用，本文的目的就是教会大家怎么使用这两个工具，因为强大所以配置也非常复杂，但是我们常用的核心功能非常简单，下面我们就从实战的角度，告诉大家怎么能用其快速的构建应用，本文中的打包代码基本是 即拷贝即用。 browserify简介browserify 简单概括来说就是：按照依赖(require)打包你的js文件。并让它(node端代码)跑在浏览器环境下。浏览器兼容程度如下： 快速使用方法12npm install -g browserifybrowserify main.js -o bundle.js 假设main.js是你的node模块代码，且main.js依赖了 basicA.js basicB.js。你可以通过上述命令快速的产出bundle.js文件，在浏览器端使用，在bundle.js中会实现如下功能，所以最终代码就直接引用bundle.js即可。 增加对node的require和exports的支持，使得main.js的内容能够在浏览器端执行 分析出main.js的依赖模块basicA.js basicB.js并将其打包在bundle.js中 上述只是最简单的使用方法，详情请参考 browserify-handbook gruntfile版本react工程最简配置（支持文件修改自动部署）我们知道react是支持使用node模块和页面内嵌jsx,但是一般来说，react应用还是需要打包的步骤，将jsx的语法解析成对应的js执行。browsify支持react项目的打包，只需要引入对应的reactify 插件即可。最简单的配置如下： 1234567891011//package.json&#123; \"name\": \"react-app\", \"version\": \"0.0.1\", \"dependencies\": &#123; \"grunt\": \"^0.4.5\", \"grunt-browserify\": \"^3.3.0\", \"grunt-contrib-watch\": \"^0.6.1\", \"reactify\": \"^1.0.0\" &#125;&#125; 123456789101112131415161718192021222324252627//gruntfile文件配置//其中所有的jsx组件放到src下，而最终的入口文件为app.js//开发的时候执行grunt watch就可以监控src中所有jsx模板将其翻译成对应的js模块，在最终的html中引入bundle.js即可module.exports = function(grunt) &#123; grunt.initConfig(&#123; pkg: grunt.file.readJSON('package.json'), watch: &#123; browserify: &#123; files: ['src/**/*.js*', 'app.js'], tasks: ['browserify'] &#125; &#125;, browserify: &#123; example : &#123; src: ['app.js'], dest: 'bundle.js', options: &#123; transform: ['reactify'] &#125; &#125; &#125; &#125;); grunt.loadNpmTasks('grunt-contrib-watch'); grunt.loadNpmTasks('grunt-browserify'); grunt.registerTask('bundle-example', ['browserify:example']);&#125;; webpack简介webpack 也是一个强大的模块管理工具，它将所有的资源都算作一个模块，如下图。 和前面提到的browsify相比，browsify只是支持js的打包，webpack更加的智能，主要体现： 支持CommonJs和AMD模块。 支持模块加载器和插件机制，可对模块灵活定制，比如babel-loader加载器，有效支持ES6。 可以通过配置，打包成多个文件。有效利用浏览器的缓存功能提升性能。 将样式文件和图片等静态资源也可视为模块进行打包。配合loader加载器，可以支持sass，less等CSS预处理器。 内置有source map，即使打包在一起依旧方便调试。 快速使用方法12345npm install -g webpack##支持的命令行参数有:-d:支持调试；-w支持实时的编辑打包；-p支持压缩webpack -dwebpack -wwebpack -p webpack的默认文件名为：webpack.config.js，下面就介绍一个简单的工程所使用的webpack配置。 12345678910111213141516171819202122//单入口文件的打包var path = require(\"path\");module.exports = &#123; entry: './src/search.js', //单入口文件 output: &#123; path: path.join(__dirname, 'out'), //打包输出的路径 filename: 'bundle.js', //打包后的名字 publicPath: \"./out/\" //html引用路径，在这里是本地地址。 &#125;&#125;;//多入口文件module.exports = &#123; entry: &#123; bundle_page1: \"./src/search.js\", bundle_page2: \"./src/login.js\" &#125;, output: &#123; path: path.join(__dirname, 'out'), publicPath: \"./out/\", filename: '[name].js'//最后产出的文件为 out/bundle_page1.js out/bundle_page2.js &#125;&#125;; webpack加载器和插件webpack最大的特色就是支持很多的loader，这些loader为复杂的应用构建提供了便利的部署环境，而不仅仅局限于node文件的浏览器环境打包而已。常用的加载器有哪些呢，这里会介绍这几个的用法。 babel-loader：不仅可以做ES6-ES5的loader还可以用来实现jsx的编译 less-loader:用于将less编译成对应的css css-loader：加载css文件 style-loader：转化成内置的样式。上面三个常常一起使用，style!css!less，loader之间用!连接。在项目中直接 require(‘xxx.less’)即可 json-loader url-loaderimage sprite 的替代方案，会将制定的图片文件合并加载，有limit参数 extract-text-webpack-plugin:项目中如果不采用按需加载，而是要将所有的css打包成一个文件，并使用link加载，这个插件就有所帮助了。 webpack实战一个工程配置有了上述的loader，我们就可以做很多的项目配置了，假设我们有个实际的项目, 基本的操作都包括如下这些环节，我们该如何使用webpack实现这个功能配置呢？ JS编译与加载：loader + react模板开发 CSS编译与加载：less编译 JS与CSS压缩 12345678910111213//package.json&#123; \"name\": \"order-view\", \"version\": \"0.0.1\", \"dependencies\": &#123; \"babel-loader\": \"\", \"less-loader\": \"\", \"css-loader\": \"\", \"style-loader\": \"\", \"autoprefixer-loader\": \"\", \"extract-text-webpack-plugin\":\"\" &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// webpack.config.js// 执行webpack -p即可完成压缩var path = require(\"path\");var ExtractTextPlugin = require(\"extract-text-webpack-plugin\");module.exports = &#123; //多文件入口 entry: &#123; bundle_page1: \"./src/search.js\", bundle_page2: \"./src/login.js\" &#125;, //指定文件的输出 output: &#123; path: path.join(__dirname, 'out'), publicPath: \"./out/\", filename: '[name].js' &#125;, module: &#123; loaders: [ //处理react模板的配置 &#123; test: /.jsx?$/, exclude: /(node_modules|bower_components)/, loader: 'babel' &#125;, //生成内置的样式&amp;lt;style&amp;gt; //&#123; // test: /.less$/, // exclude: /(node_modules|bower_components)/, // loader: \"style!css!less\" //&#125;, //将依赖打包成一个css文件 &#123; test: /.less$/, exclude: /(node_modules|bower_components)/, test: /.less$/, loader: ExtractTextPlugin.extract( 'css?sourceMap&amp;amp;-minimize!' + 'autoprefixer-loader!' + 'less?sourceMap' ) &#125;, //图片自动合并加载 &#123; test: /.(jpg|png)$/, loader: \"url?limit=8192\" &#125; ] &#125;, plugins: [ new ExtractTextPlugin('[name].css') ]&#125;;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://mengbaby.github.io/categories/javascript/"},{"name":"workflow","slug":"javascript/workflow","permalink":"https://mengbaby.github.io/categories/javascript/workflow/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mengbaby.github.io/Mtags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://mengbaby.github.io/Mtags/nodejs/"},{"name":"browserify","slug":"browserify","permalink":"https://mengbaby.github.io/Mtags/browserify/"},{"name":"webpack","slug":"webpack","permalink":"https://mengbaby.github.io/Mtags/webpack/"},{"name":"前端自动化部署","slug":"前端自动化部署","permalink":"https://mengbaby.github.io/Mtags/前端自动化部署/"},{"name":"工具","slug":"工具","permalink":"https://mengbaby.github.io/Mtags/工具/"},{"name":"敏捷开发","slug":"敏捷开发","permalink":"https://mengbaby.github.io/Mtags/敏捷开发/"}]},{"title":"React生命周期、API和深入用法","slug":"react-depth","date":"2015-09-06T03:04:22.000Z","updated":"2017-04-17T07:55:18.000Z","comments":true,"path":"2015/09/06/react-depth/","link":"","permalink":"https://mengbaby.github.io/2015/09/06/react-depth/","excerpt":"","text":"React火了很久了，一直都停留在照葫芦画瓢按照example凑数的基础上，但是如果真的要了解一个框架，它的生命周期和核心API是最重要的部分了，下面我们就来聊聊React的生命周期、核心API的用法以及React工具集，在使用React进行深度开发的时候，一定会事半功倍。本文假设你已经了解了React的基本开发知识，如果不了解，强烈推荐阮老师的这篇《React 入门实例教程》 一、生命周期 1、创建一个类和实例化的基础方法123456789101112 //创建组件类var ComponentBox = React.createClass(&#123; //other lifecycle method render: function () &#123; //return JSX code &#125;&#125;);//实例化组件var compInstance = React.render( &lt;ComponentBox /&gt;, document.getElementById('content') //DOM Element); 2、了解this.state和this.prop使用过React的人都会知道它有两个属性，state还有props，他们两者都可以作为render中的data输入源，那两者的区别、联系以及正确的用法又是怎么样的呢。参见这篇《props-vs-state》 。 prop是组件的配置项，是可选的，当组件接收这个参数后它就是不变的。组件改变不了它的props，父组件的props还担当着收集子组件配置项的功能。 state，在组件初始化的时候会赋予state初始的状态，当组件的状态发生变化的时候，组件内部自行管理着state的变化，所以state可以说是组件的私有值。state参数是可有可无的，但当你的组件是“Stateful Component”的时候你就应该考虑使用state了。 两者在组件变化的时候的状态改变如下: - props state Can get initial value from parent Component? Yes Yes Can be changed by parent Component? Yes No Can set default values inside Component?* Yes Yes Can change inside Component? No Yes Can set initial value for child Components? Yes Yes Can change in child Components? Yes No 那么两者如何合理的使用和规划呢。举例来说,在官网《thinking-in-react》有这样的一个例子，组件如下图，当需要有过滤和搜索功能的时候，其实组件就是一个“具有状态的组件”了，需要有state管理对应的状态。通过分析，我们可以得到对应的变量规划： 用于表示所有产品列表的 products 用于表示过滤后的列表 (filterProducts) 表示是否使用过滤的功能(checkValue) 使用搜索过滤的关键词(searchValue) 要分析变量是否是state，主要考虑这几个问题： 变量是否会通过父组件传递参数，如果是，那么它肯定不是state，这里products 肯定不是state 变量是否会出现变化，如果不会出现变化，那么它肯定不是state 你会不会根其他的state或者props计算这个值，如果是经过计算得到的，那么它一定不是state，由此可见filterProducts也不是state再考虑 checkValue和 searchValue在本质上是随组件内部改变的，所以，这两个变量应该作为state管理。所以最后的程序如下 See the Pen React filter list demo by zhangmeng (@zhangmeng712) on CodePen. 3、生命周期详情分析1) 初始化阶段 getDefaultProps getInitialState propTypes Mixins statics displayName getDefaultProps初始化参数使用，当组件类被创建的时候会被调用一次。输入为函数类型，返回object为this.props的初始化值，当父组件没有指定具体参数的时候，参数会在这个方法中被详细映射，此外 为了增加程序的可读性和容错性，建议在这个方法中指定好参数的初始值。 12345678910111213141516171819202122232425262728/*Input.jsx*//*Form是input的父组件*/module.exports = React.createClass(&#123; displayName: 'Input', getDefaultProps: function () &#123; return &#123; //父组件中具体的参数映射，为了程序更加清晰，建议所有的props都在getDefaultProps中定义 model: &#123; name: '', type: '', value: '', error: false, enabled: true &#125; &#125;; &#125;&#125;);/* Form.jsx */module.exports = React.createClass(&#123; displayName: 'Form', render: function () &#123; return (&lt;form&gt; &lt;Input model=&#123;fieldModel&#125; ref=&#123;fieldModel.name&#125;/&gt; &lt;/form&gt;); &#125;&#125;) getInitialState初始化state使用，在组件mount之前被调用一次。输入为函数，返回object为this.state的初始化值。propTypes用于属性的验证使用，输入为object。如果输入的类型和验证中设置的类型不符，在dev环境会给出提示。除了React内置的类型如 React.PropTypes.array，还支持自定义类型，详情见Reusable Components. 12345678910111213141516171819202122232425var ComponentBox = React.createClass(&#123; //默认值设置 getDefaultProps: function () &#123; return &#123; initalX: 14, initalProp: '11', //内置校验 customProp: 'hi' //自定义校验 &#125; &#125;, //允许校验属性的方法，只在dev环境会显示warn propTypes: &#123; //React内置类型 initalProp: React.PropTypes.array, //自定义类型 customProp: function (props, propName,componentName) &#123; if (props[propName] !== 'hello') &#123; return new Error('Validation failed, customProp value needs to be hello'); &#125; &#125; &#125; &#125;); var compInstance = React.render( &lt;ComponentBox /&gt;, document.getElementById('content') //DOM Element ); Mixins输入为array类型，用于定义组件间共享的方法，其中的方法可以是生命周期的方法，也可以是自定义方法。不过有几点需要注意： 定义在其内部的方法会优先于类上的方法执行 在Mixins中和类上同时定义render方法会抛出异常（Uncaught Error: Invariant Violation: ReactClassInterface: You are attempting to define render on your component more than once） 在Mixins数组中定义同样名称的非生命周期方法也会抛出异常（Uncaught Error: Invariant Violation: ReactClassInterface: You are attempting to define logFunc on your component more than once. ） 12345678910111213141516171819202122232425262728var commonMixins = &#123; getDefaultProps: function() &#123; return &#123; initalY: 20 &#125; &#125; &#125;; var commonMixins1 = &#123; //定义2个render定义会抛出异常 // render: function () &#123; // // &#125; // 定义同样名称的非生命周期方法也会抛出异常 logFunc: function() &#123; console.log('Mixins log method') &#125; &#125;; var commonMixins2 = &#123; logFunc: function() &#123; console.log('Mixins log method') &#125; &#125;; var ComponentBox = React.createClass(&#123; mixins: [commonMixins,commonMixins1,commonMixins2] &#125;); var compInstance = React.render( &lt; ComponentBox / &gt; , document.getElementById('content') //DOM Element ); statics类上的静态方法，可以在实例化之前被类自己调用。displayName用于在调试信息中标示组件，JSX会自动的设置它的值 2) Mounting阶段 componentWillMount componentDidMountcomponentWillMount只会被调用一次。运行于初始化之后，render方法之前。当在此函数中调用setState后，render会显示被修改的state内容，注意，尽管state内容被改变了，但是不会再多次调用render。componentDidMount在render执行之后被调用，这个方法只会被调用一次。在这个方法中，可以通过React.findDOMNode(this)对组件的dom元素进行操作，子组件的componentDidMount方法会优先于父组件的componentDidMount方法被调用。我们会在这个方法中执行ajax请求或者调用timer或者用其他类库进行交互。 12345678910111213141516171819componentDidMount: function () &#123; console.log('-------componentDidMount execute-------') var input = $('input[type=\"text\"]'); input.focus(); var cityName = this.props.propValue; $.get('http://api.openweathermap.org/data/2.5/weather?q=' + cityName , function (data,status) &#123; if (status === 'success') &#123; var weather = data.weather || []; if (weather.length &amp;&amp; weather[0]) &#123; this.setProps(&#123; weather: weather[0].description &#125;); &#125; &#125; &#125;.bind(this)) &#125; 3) 数据更新阶段 componentWillReceiveProps shouldComponentUpdate componentWillUpdate componentDidUpdatecomponentWillReceiveProps当新的props参数被发现时，就会调用这个方法，普通的render之后是不调用这个函数的。改变之前的props参数可以通过 this.props获得，新的参数可以通过第一个入参获得。在这个方法中调用setState不会触发额外的render调用。 123componentWillReceiveProps: function (nextProps) &#123; console.log('-------componentWillReceiveProps execute-------', 'old weather is this.props.weather:', this.props.weather, 'new props is nextProps.weahter:' + nextProps.weather); &#125; shouldComponentUpdate当props和state变化后被触发，初次render和强制更新的时候此方法不会被调用。当你希望某个props或者state的值改变的时候，不需要render被再次执行，就可以在shouldComponentUpdate中return false来实现，而此时接下来的 componentWillUpdate 和componentDidUpdate也不会执行。默认shouldComponentUpdate会自动返回true，但是你可以通过比较参数的变化来重写这个函数，如下： 12345678shouldComponentUpdate: function (nextProps, nextState) &#123; console.log('-------shouldComponentUpdate execute-------') var flag = true; if (nextProps.weather == 'light rain' ) &#123; flag = false; &#125; return flag; &#125; componentWillUpdate判断完是否能调用render之后，就会执行componentWillUpdate，这个函数是用作render之前发生更新的改变。在这个方法中不能使用setState方法，如果要更新state，在componentWillReceiveProps函数中进行处理。componentDidUpdate当参数变更完成，render执行完成DOM完全被更新之后会触发，可用于操作新更新的DOM元素，入参为 prevProps和 prevState，以防操作中需要变更前的数据 4) Unmounting阶段 componentWillUnmountcomponentDidUpdate当组件从DOM中销毁的时候调用，可在函数中对timer和不需要的dom元素进行清理关于组件的生命周期执行顺序和props更新流程等可以参考以下的例子：See the Pen React lifycycle testing by zhangmeng (@zhangmeng712) on CodePen. 二、你应该掌握的API用法1、常用 API React.createClass React.render React.findDOMNode React.createElement:创建一个virtual dom进行渲染，可以使用React.render进行加载 React.Children: 用于处理组件中的this.props.children React.Children.map React.Children.only React.Children.forEach React.Children.count 2 组件相关API this.setState：设置state，除了支持key value的传送方式，还支持传入fn, 注意通过上述的描述可以调用它的生命周期方法为:componentDidMount以及componentWillMount（不会触发刷新render，但是可以赋值）。 this.setProps：设置props this.props.children：表示在实例化的时候传入组件的所有子节点，可以通过React.Children来统一处理渲染到页面上 this.props.refs：render中Dom Node可以用ref来标示，这样就可以利用React.findDOMNode(this.refs.xx)来获取对应的DOM元素了。ref可以传入名称，也可以传入函数更多详情 123456789101112131415161718192021222324252627282930313233343536373839//setState的函数传入，入参为之前的state对象，还有当前的props对象 this.setState(function (prevState, currentProps) &#123; return &#123; stateValue: 'new stateValue' &#125; &#125;);//操作this.props.children var ComponentBox = React.createClass(&#123; render: function () &#123; return (&lt;ul&gt; &#123; //能够渲染 React.Children.map(this.props.children, function (child) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt; &#125;) &#125; &#123; // 返回不是object ？渲染不出 React.Children.forEach(this.props.children, function (child) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt;) &#125; &#125;);var compInstance = React.render( &lt;ComponentBox&gt;&lt;span&gt;list1&lt;/span&gt;&lt;span&gt;list2&lt;/span&gt;&lt;/ComponentBox&gt;, document.getElementById('content') //DOM Element );//refs的用法&lt;input ref=&#123; function(component)&#123; React.findDOMNode(component).focus();&#125; &#125; /&gt;&lt;input type=\"text\" ref=\"myTextInput\" defaultValue=&#123;this.props.propValue&#125; /&gt; var input = React.findDOMNode(this.refs.myTextInput) 3、Add-on API Animation API: ReactCSSTransitionGroup 用于控制动画的标签。 transitionName 定义动画的class前缀，以下例为基础默认在标签内新增的的元素，动画效果的className为example-enter example-enter-active；元素被删除时候效果的className为 example-leave example-leave-active transitionAppear v0.13开始有的方法，用于书写初始化的动画效果，默认是false。注意：一定要先让ReactCSSTransitionGroup这个标签渲染出来，然后再在标签内增加元素，否则效果不生效。 有人在使用这个Add-on的时候遇到了动画时序的问题，也可以使用自定义的动画解决，参考这个例子 &lt;ReactCSSTransitionGroup transitionName=\"example\" transitionAppear={true}&gt; {items} &lt;/ReactCSSTransitionGroup&gt; See the Pen react animtion test by zhangmeng (@zhangmeng712) on CodePen. Test-Utils API:Test-Utils API: 一般的类库很少提供这种Add-on，更多是通过工具对其进行补充，例如Angular的protractor，以及Polymer的web-componnets-tester，这点React还是想的很全面的，当然它也有对其组件测试的Jest框架，但是通过它的Test-Utils可以结合其它的测试框架进行测试。 Simulate点击：React.addons.TestUtils.Simulate.click(node); 渲染组件：ReactTestUtils.renderIntoDocument(); 获取组件:findRenderedDOMComponentWithClass Mock组件：mockComponent 参考实例1：Building robust web apps with React: Part 3, testing with Jasmine 参考实例2：测试驱动编写 React 简易计算器 三 组件的拆分和数据的传递一般来说，稍微复杂的组件可以被拆分成若干组件（拆分本着一个组件只做一件事情的原则，参见Single_responsibility_principle）。合理的组件拆分会让React组件的开发复用性更强，那么在组件中如何管理组件间数据的传递？具体可以参考《How to communicate between React components》这篇文章，讲解的非常详细。 参考资料 https://github.com/uberVU/react-guide/blob/master/props-vs-state.md http://ctheu.com/2015/02/12/how-to-communicate-between-react-components/#child_to_parent http://facebook.github.io/react/docs/thinking-in-react.html","categories":[{"name":"javascript","slug":"javascript","permalink":"https://mengbaby.github.io/categories/javascript/"},{"name":"react","slug":"javascript/react","permalink":"https://mengbaby.github.io/categories/javascript/react/"}],"tags":[{"name":"React","slug":"React","permalink":"https://mengbaby.github.io/Mtags/React/"}]},{"title":"mobile H5布局大全-rem flexbox详解","slug":"mobile-layout","date":"2015-03-15T01:29:14.000Z","updated":"2017-04-17T07:21:17.000Z","comments":true,"path":"2015/03/15/mobile-layout/","link":"","permalink":"https://mengbaby.github.io/2015/03/15/mobile-layout/","excerpt":"","text":"\\现在无线端的开发如火如荼，不同于国外网站经常做的响应式设计,国内很多大型网站都会专门实现基于H5的手机端mobile站点代码，淘宝、天猫、京东、百度等等，大抵是为了尽可能的减少设计和代码维护成本，也可能是为了实现代码的最小化减少请求代码量，虽然个人还是更倾向于响应式设计，但了解一些具有“无线端前端”开发的知识也未尝不是件好事。说起无线端开发，布局应该是最最具代表性的专题之一，因为不考虑ie系列的兼容性，因此除了pc端常常使用的浮动、表格、百分比布局等等 ，rem和flexbox更是火热的无线端布局实现手段，下面我们就从最基本的概念css像素看起，彻底的了解无线端的布局~~ 一、viewport和像素物理像素、CSS像素、独立像素和devicePixelRatio 物理像素 device pixel: 物理像素指显示设备上的物理像素点 CSS像素 css pixel: 指我们写页面时理解的那个像素单位px 独立像素dp: （dips device independent pixels）: DP用在Android上，PT用在Apple上 衡量设备的物理像素密度 DPI 和 PPI DPI 指 Dots Per Inch（dpi ldpi mdpi hdpi for android） PPI指 Pixels Per Inch。 http://dpi.lv/ window.devicePixelRatio = 物理像素/dips(dp) 等效于ddpx dppx : device pixel / css pixel; 分辨率（Resolution）：屏幕区域的宽高所占像素数 设计师DPI指南 viewport和devicePixelRatio meta viewport width:sets the width of the layout view port to the indicated value. device-width initial-scale: sets the initial zoom factor of the page and the width of the layout viewport. minimum-scale: sets the minimum zoom level (how much the user can zoom out). maximum-scale: sets the maximum zoom level (how much the user can zoom in). user-scalable: prevents user zooming when set to no. This is evil and we will demonstratively ignore it. 使用viewport和devicePixelRatio实现兼容retina屏幕的像素 devicePixelRatio测试：http://www.quirksmode.org/m/tests/widthtest_vpdevice.html css中使用devicePixelRatio .css{ background-image: url(img_1x.png); } /* 高清显示屏(设备像素比例大于等于2)使用2倍图 */ @media only screen and (-webkit-min-device-pixel-ratio:2){ .css{ background-image: url(img_2x.png); } } /* 高清显示屏(设备像素比例大于等于3)使用3倍图 */ @media only screen and (-webkit-min-device-pixel-ratio:3){ .css{ background-image: url(img_3x.png); } } vh单位：相对于视口的高度。视口被均分为100单位的vh 二、REM布局rem原理 使用相对尺寸的一种，随着页面宽度的改变，html的font改变，控制页面用rem标记元素的尺寸 相对于百分比布局，控制局部尺寸更加方便 参考 淘宝无线首页 代码 需要设置基准元素还有最大的字体元素（防止全屏） 核心计算公式 页面宽度：getBoundingClientRect还是width htmlFont = min[pageWidth/(psdWidth/basicFont, maxFont) text-size-adjust调整100% html font size的设置 拼css完成 而不是document.documentElement.style.fontSize 绑定处理 DOMContentLoaded load resize 从未设置viewport的网页进入重新设置一下 pageshow/load persisted(是否后退进入) 实战无线团队的lib.flexible 1 代码 2 不同点 为了快速兼容vh单位 将布局分为了100份 根据dpr控制meta的值，这样可以保证分别处理不同dpr的样式，但是增加了开发复杂度 三、Flexbox盒模型原理 版本 2009: http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/ 2011: http://www.w3.org/TR/2011/WD-css3-flexbox-20110322/ 2015: http://www.w3.org/TR/2014/WD-css-flexbox-1-20140925/ display: -webkit-box; display: -moz-box; //2009 display: -ms-flexbox;//2011 display: -webkit-flex; display: flex; //now ‘APIS’ demo flex type display: inline-flex (make element inline-block) display: flex (make element block) direction flex-direction:row row-reverse column column box-orient:horizontal vertical wrap flex-wrap: nowrap | wrap(if not enough place will put content to the next row/column ) | wrap-reverse (should not use in mobile safari) flex-flow(direction wrap) flex-flow: row nowrap; justify-content(horizontal distribution) justify-content: flex-start | flex-end | center | space-between | space-around;(should not use in mobile safari) horizontal center: -webkit-box-pack:center; -webkit-justify-content:center; -ms-flex-pack:center; justify-content:center; align-items (vertical distribution) align-items: flex-start | flex-end | center | baseline | stretch https://developer.mozilla.org/en-US/docs/Web/CSS/align-items -webkit-box-align:center; -webkit-align-items:center; -ms-flex-align:center; align-items:center; align-self used for flex items to change its align-items align-items used for flex container flex-grow flex-shrink 兼容性 flexbugs autoprefix工具实战 两栏布局 复杂布局 四、常见布局-等分和居中 实现手段：float rem flex box table等等（inline-block局部手机浏览器会有bug） 等分布局实现方案demo 五、常见布局-图片布局 background-size 图片自适应：padding-bottom srcset（兼容性不好） 图片优化（压缩比和Webp） webp 淘宝解决方案 内网 无线端图片响应式demo 六、代码转化为模板建立解决方案 solved by Flexbox demo 七、其他测试新手段可以选择不同机型不同的ADT实现测试-虽然付费但是相当的赞~~~ browserstack","categories":[{"name":"css3","slug":"css3","permalink":"https://mengbaby.github.io/categories/css3/"},{"name":"h5","slug":"css3/h5","permalink":"https://mengbaby.github.io/categories/css3/h5/"},{"name":"mobile","slug":"css3/h5/mobile","permalink":"https://mengbaby.github.io/categories/css3/h5/mobile/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://mengbaby.github.io/Mtags/css3/"},{"name":"flexbox","slug":"flexbox","permalink":"https://mengbaby.github.io/Mtags/flexbox/"},{"name":"mobile","slug":"mobile","permalink":"https://mengbaby.github.io/Mtags/mobile/"},{"name":"mobile-layout","slug":"mobile-layout","permalink":"https://mengbaby.github.io/Mtags/mobile-layout/"},{"name":"rem","slug":"rem","permalink":"https://mengbaby.github.io/Mtags/rem/"},{"name":"viewport","slug":"viewport","permalink":"https://mengbaby.github.io/Mtags/viewport/"}]},{"title":"css3和动画-part1-变换","slug":"css3-animation-part1","date":"2015-02-03T03:15:22.000Z","updated":"2017-04-17T06:26:29.000Z","comments":true,"path":"2015/02/03/css3-animation-part1/","link":"","permalink":"https://mengbaby.github.io/2015/02/03/css3-animation-part1/","excerpt":"","text":"常年开发web后台系统，实在厌恶了做不完的需求、调不完的接口、和各种数据交互，所以闲暇之余开始了动画和游戏的学习，也算一种调剂。动画比游戏应用更为广泛，所以我们先从动画说起，这系列教程主要包括如下几篇文章： css3和动画-part1 基础篇；css3动画基础和实例（有demo有真相 力求比w3cschool实用些） css3和动画-part2 进阶篇；理论结合实际实现几个较为复杂但有意思的动画效果 css3和动画-part3 蛋疼篇；transform、matrix和贝塞尔曲线 javascript和动画-part1 姊妹篇；使用javascript完成动画 javascript和动画-part2 姊妹进阶篇；高性能js动画类库分析-snabbt和gsap 废话不说（此处省略XXXX个字），上来先总结一下动画的相关的知识，让大家有个大概的印象，然后再各个击破。css3动画有很多名词都比较相似，例如 transform transiton translate，参数用法也特别容易混，这里我主要按照我学习的线索作为提纲分块讲解，希望对大家有所帮助： 实现各种变换效果的关键字：transform： translate opacity skew rotate… 静到动的实现函数：transition和animation 3D相关：translate3d perspective 变换 不谈代码，我们大概能想到的变换效果都有哪些呢？放大、缩小、旋转、显隐，上下左右移动， 扭曲等等。对于这些变换，css3为给我们提供了丰富的效果关键字，这篇文章主要谈论常用的、高效的变换。之所以说是高效的变换，其实主要是在渲染的过程中能够尽量减少浏览器Recalculate的变换效果，参见High Performance Animations。这些变换有: Position：translate Scale Rotate opacity transform这个是个非常重要的关键字，他的作用是，transform：需要变换的属性 不同属性直接用空格分隔,举例来说要实现 某一文字放大并向右平移50像素，代码为： 12345.second &#123; -webkit-transform: scale(1.1) translate(50px, 0); -ms-transform: scale(1.1) translate(50px, 0); transform: scale(1.1) translate(50px, 0)&#125; 下面就具体讲讲，被transform的各种变换效果。 translate如果要实现元素从某一位置变换到另一个位置的时候，我们可以使用top left进行变换， 也可以使用margin-left margin-top，但是，其实这些都是会触发浏览器的Recalculate，会让动画出现卡顿，实现效率也非常的低下，参考jsperf做的对比，也可以戳戳Paul Irish的文章。如果改用translate这个关键字就可以非常cheaply的实现动画效果。translate主要是用来改变元素坐标的一种变换。API为： transform: translate(tx[, ty]) / one or two values / transform: translateX(tx) transform: translateY(ty) 常见的场景就是使用translate实现轮播的效果，下面是轮播的最简单的一个demo实现： See the Pen wBrwwN by zhangmeng712 (@zhangmeng712) on CodePen. 最核心的代码就是： 12345.card-list.second &#123; -webkit-transform: translate(-540px, 0px); -ms-transform: translate(-540px, 0px); transform: translate(-540px, 0px);&#125; _**Tips**_: 我们不是电脑，没法记得哪些需要前缀哪些不需要，这里推荐给大家一个工具，[autoprefixer](https://github.com/postcss/autoprefixer)这个是在[caniuse](http://caniuse.com/)这个网站的基础上用来帮我们实现兼容的前缀的，我们可以只写最基本的，他自动会帮我们补全,[在线地址](http://simevidas.jsbin.com/gufoko/quiet)。 ### scale scale如同它的英文含义一样，是用来把元素进行放大缩小的，它也是非常实用的，先看API： * transform: scale(sx[, sy]); * transform: scaleX(sx);* transform: scaleY(sy); scale最常见的应用就是在鼠标hover的时候把图标进行放大，以表示选中状态，引起注意，如下面这个demo，这里也有个工具网站推荐[shapeofcss](http://css-tricks.com/examples/ShapesOfCSS/)，在这里面可以找到我们常见的形状的实现。例子中同时使用了[webfontIcon](http://fortawesome.github.io/Font-Awesome/examples/)，这个技术让前端彻底告别切图的时代。 See the Pen wBrwwN by zhangmeng712 (@zhangmeng712) on CodePen. rotaterotate是用于让元素旋转的效果。旋转效果常配合着3D的效果一起使用，实现空间化的效果；也经常配合animation实现loading spinner的效果，如下demo： transform: rotate(angle); / an , e.g., rotate(30deg) / transform: rotateX(angle);* transform: rotateY(angle); See the Pen qEPVRQ by zhangmeng712 (@zhangmeng712) on CodePen. opacityopacity的用途其实更加的广泛，不管是rotate也好scale也好，如果没有一些opacity的变化就会让变换十分的生硬。配合opacity和display的切换是会导致重排的。所以如果需要元素的隐藏显示，最好采用opacity来控制。opacity还常常和animation配合起来，用于实现fadeIn fadeOut等人性化的动画设计。注意 opacity虽然是一种效果，但是并不需要使用transform来控制。API非常简单: opacity:0.4，记得每次开一个新的项目都会有实现transparent全兼容的css的代码，在此也为大家提供一下,见CssTricks： 12345678910111213141516.transparent_class &#123; /* IE 8 */ -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=50)\"; /* IE 5-7 */ filter: alpha(opacity=50); /* Netscape */ -moz-opacity: 0.5; /* Safari 1.x */ -khtml-opacity: 0.5; /* Good browsers */ opacity: 0.5;&#125; 本来想一篇文章把“变换” “动画” 还有“3D效果”一起讲解，但发现要说的东西太多了，为了保证质量，拆分成了三篇，力求把动画的内容涵盖完全，敬请期待哦~ 参考： mozilla css tricks","categories":[{"name":"javascript","slug":"javascript","permalink":"https://mengbaby.github.io/categories/javascript/"},{"name":"css3","slug":"javascript/css3","permalink":"https://mengbaby.github.io/categories/javascript/css3/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://mengbaby.github.io/Mtags/javascript/"},{"name":"css3","slug":"css3","permalink":"https://mengbaby.github.io/Mtags/css3/"},{"name":"html5","slug":"html5","permalink":"https://mengbaby.github.io/Mtags/html5/"}]}]}